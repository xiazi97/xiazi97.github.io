<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Snoopy</title>
  
  <subtitle>点个关注吧，亲</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiazi97.github.io/"/>
  <updated>2018-11-30T14:46:31.636Z</updated>
  <id>http://xiazi97.github.io/</id>
  
  <author>
    <name>李峰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络基础（一）</title>
    <link href="http://xiazi97.github.io/2018/11/30/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiazi97.github.io/2018/11/30/网络基础（一）/</id>
    <published>2018-11-30T14:45:41.000Z</published>
    <updated>2018-11-30T14:46:31.636Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据传输（ (不)同主机上的进程间同信）&lt;/p&gt;
&lt;p&gt;协议：(通信双方的一个数据格式协议)&lt;/p&gt;
&lt;p&gt;网络中主机之间进行通信也必须使用相同的协议（相同的一个光电信号格式）&lt;/p&gt;
&lt;p&gt;计算机如何传播数据—-光电波信号&lt;/p&gt;
&lt;p&gt;在网络中因为主机设备的生产厂商很多
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://xiazi97.github.io/2018/11/26/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://xiazi97.github.io/2018/11/26/深浅拷贝/</id>
    <published>2018-11-26T15:59:25.000Z</published>
    <updated>2018-11-28T13:01:04.370Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象之间可以进行复制操作，包括采用拷贝构造函数的方式用一个对象去构造另一个对象（用一个对象的值初始化一个新的构造的对象），如同指针的复制一样，对象复制也分为浅复制和深复制&lt;/p&gt;
&lt;p&gt;对象浅拷贝：&lt;/p&gt;
&lt;p&gt;两个对象之间进行复制时，若复制完成后，他们还共同使用着某些资
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xiazi97.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://xiazi97.github.io/2018/11/19/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://xiazi97.github.io/2018/11/19/模板/</id>
    <published>2018-11-19T15:09:03.000Z</published>
    <updated>2018-11-29T09:13:36.244Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何实现一个通用的函数呢？（如针对不同的参数类型均可）&lt;/p&gt;
&lt;p&gt;使用函数重载可以实现，但是使得代码复用率和可维护性比较低&lt;/p&gt;
&lt;p&gt;泛型编程：&lt;/p&gt;
&lt;p&gt;编写与类型无关，与使用场景无关的通用代码，使得代码可以复用&lt;/p&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;p&gt;函数模板：
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xiazi97.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>动态内存管理</title>
    <link href="http://xiazi97.github.io/2018/11/15/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://xiazi97.github.io/2018/11/15/动态内存管理/</id>
    <published>2018-11-15T15:26:17.000Z</published>
    <updated>2018-11-15T15:26:17.646Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>父子进程之SIGCHLD</title>
    <link href="http://xiazi97.github.io/2018/11/11/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8BSIGCHLD/"/>
    <id>http://xiazi97.github.io/2018/11/11/父子进程之SIGCHLD/</id>
    <published>2018-11-11T14:49:55.000Z</published>
    <updated>2018-11-11T15:21:47.147Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    在用wait和waitpid函数处理僵尸进程时，父进程可以阻塞等待子进程结束，也可以非阻塞的查询是否有子进程结束等待处理。但是，第一种方式父进程阻塞了就不能处理自己的工作了，而第二种父进程在处理自己的工作时还需要时不时的轮询一下，使得程序变得复杂。而在子进程终止时
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>可重入函数</title>
    <link href="http://xiazi97.github.io/2018/11/10/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0/"/>
    <id>http://xiazi97.github.io/2018/11/10/可重入函数/</id>
    <published>2018-11-10T07:28:16.000Z</published>
    <updated>2018-11-11T10:59:27.298Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不可重入函数：如果函数在不同的地方/时序进行调用，会对函数的功能逻辑造成影响&lt;/p&gt;
&lt;p&gt;可重入函数：不管怎么调用都不会对函数内部功能/程序逻辑造成影响（局部变量）&lt;/p&gt;
&lt;p&gt;下面具体演示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程信号之自定义处理</title>
    <link href="http://xiazi97.github.io/2018/11/10/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86/"/>
    <id>http://xiazi97.github.io/2018/11/10/进程信号之自定义处理/</id>
    <published>2018-11-10T02:22:03.000Z</published>
    <updated>2018-11-10T02:37:21.966Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;信号的捕捉流程：主要是针对信号的自定义处理方式&lt;/p&gt;
&lt;p&gt;信号并不是立即处理的，而是选择一个合适的时机去处理，合适的时机就是当前程序从内核态切换到用户态的时候&lt;/p&gt;
&lt;p&gt;注意：程序如何从用户态切换到内核态?&lt;/p&gt;
&lt;p&gt;答：1.程序异常的时候    2.发起系统调
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件权限</title>
    <link href="http://xiazi97.github.io/2018/11/08/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>http://xiazi97.github.io/2018/11/08/Linux文件权限/</id>
    <published>2018-11-08T15:37:20.000Z</published>
    <updated>2018-11-09T14:55:11.230Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    在Linux系统下，一切皆文件，而对于一个文件必定需要权限去对其进行访问和操作，那么对于用户来说，可以通过哪些权限来访问文件呢？&lt;/p&gt;
&lt;p&gt;​    首先，我们需要对Linux系统下文件访问权限有一定的了解：​&lt;/p&gt;
&lt;p&gt;文件权限值的表示方法：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程信号之信号周期</title>
    <link href="http://xiazi97.github.io/2018/11/08/%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%91%A8%E6%9C%9F/"/>
    <id>http://xiazi97.github.io/2018/11/08/进程信号之信号周期/</id>
    <published>2018-11-08T14:26:27.000Z</published>
    <updated>2018-11-08T14:46:36.181Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;信号是为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去处理事件，事件处理完毕之后进程回到原先运行位置继续运行&lt;br&gt;信号更多的是通知事件发生，如红绿灯&lt;/p&gt;
&lt;p&gt;在LInux下，用户输入命令在Shell下启动一个前台进程，而当按下c
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Core Dump浅解析</title>
    <link href="http://xiazi97.github.io/2018/11/08/Core-Dump%E6%B5%85%E8%A7%A3%E6%9E%90/"/>
    <id>http://xiazi97.github.io/2018/11/08/Core-Dump浅解析/</id>
    <published>2018-11-08T09:39:53.000Z</published>
    <updated>2018-11-08T09:48:17.058Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Core Dump（核心转储）：&lt;br&gt;当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，叫做Core Dump(保存当前程序运行的数据以及调用栈信息)，可以用于错误原因定位调试&lt;/p&gt;
&lt;p&gt;为什么不用gdb呢？&lt;br&gt;答：如
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://xiazi97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>new与delete的使用</title>
    <link href="http://xiazi97.github.io/2018/11/07/new%E4%B8%8Edelete%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiazi97.github.io/2018/11/07/new与delete的使用/</id>
    <published>2018-11-07T08:50:13.000Z</published>
    <updated>2018-11-07T08:53:21.661Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;new运算符是给指针分配一片内存空间，与delete运算符一起使用，以达到直接进行动态内存分配和释放的目的&lt;br&gt;new返回指定类型的一个指针，如果分配失败（如没有足够的内存空间），则返回0&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xiazi97.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>类中默认成员函数浅析（二）</title>
    <link href="http://xiazi97.github.io/2018/11/05/%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://xiazi97.github.io/2018/11/05/类中默认成员函数浅析（二）/</id>
    <published>2018-11-05T14:55:24.000Z</published>
    <updated>2018-11-05T15:06:56.136Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;运算符重载：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;operator + 合法的运算符 构成函数名（举例：重载&amp;lt;运算符的函数名：operator&amp;lt; ）。&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;重载运算符以后，不能改变运算符的 优先级/结合性/操作数个数。&lt;br&gt;3.若成员变量
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xiazi97.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>for循环的基础练习</title>
    <link href="http://xiazi97.github.io/2018/11/01/for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/"/>
    <id>http://xiazi97.github.io/2018/11/01/for循环的基础练习/</id>
    <published>2018-10-31T16:15:57.000Z</published>
    <updated>2018-10-31T16:41:23.445Z</updated>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论是对于编程菜鸟或者是大牛来说，for循环是一个不可或缺的C语言语句，在这里其定义如何&lt;br&gt;且按下不表，只是单纯的放几个for循环的适用场景来感受一下。&lt;br&gt;for(表达式1；表达式2；表达式3)，请对应于下图来认真体会一下&lt;br&gt;&lt;img src=&quot;/2018/11
      
    
    </summary>
    
    
      <category term="C初阶基本练习" scheme="http://xiazi97.github.io/tags/C%E5%88%9D%E9%98%B6%E5%9F%BA%E6%9C%AC%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>类中默认成员函数浅析（一）</title>
    <link href="http://xiazi97.github.io/2018/10/30/%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://xiazi97.github.io/2018/10/30/类中默认成员函数浅析（一）/</id>
    <published>2018-10-29T16:10:05.000Z</published>
    <updated>2018-10-29T16:12:10.471Z</updated>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;构造函数：&lt;br&gt;是一个特殊的成员函数（随着对象创建而自动被调用的），用于来初始化对象，在对象的生命周期中只调用一次&lt;br&gt;特征：&lt;br&gt;1.名字与类名相同&lt;br&gt;2.无返回值（并不等同于void）&lt;br&gt;3.可以重载（类可以有多个构造函
      
    
    </summary>
    
    
      <category term="C++" scheme="http://xiazi97.github.io/tags/C/"/>
    
  </entry>
  
</feed>
