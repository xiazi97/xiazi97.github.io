<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP协议]]></title>
    <url>%2F2019%2F01%2F07%2FTCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[对于常见的网络协议来说，TCP是最为人知晓的，即便是一些业外人士只要对电脑网络有一定的了解也能说上几句，那么广为人知的TCP协议到底是什么呢，下边作为一个初学者的视角来浅谈一下 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议 。常用于一次传输要交换大量报文的情形，如文件传输，远程登陆等。为了实现这种端到端的可靠传输，TCP必须规定传输层的连接建立与拆除的方式，数据传输格式，确认的方式，目标应用进程的识别以及差错控制和流量控制机制等。 TCP的协议数据单元被称为分段，TCP通过分段的交互来建立连接，传输数据，发出确认，进行差错控制，流量控制及关闭连接。 TCP分段格式： TCP协议段格式 源/目的端口号：表示数据从哪个进程来，到哪个进程去； 32位序号：该分段在发送方的数据流中的位置，用来保证到达数据顺序的序号 32位确认序号：下一个期望接收的分段序号，相当于是对方发送的并已经被本方正确接收的分段的确认 4位首部长度：TCP头长，以32位字长为单位。表示该TCP头部有多少个4字节，所以TCP头部最大长度为15*4=60，实际相当于给出数据在数据段中的开始位置 保留：占6比特，目前置为“0” 六位标志位： URG：紧急指针是否有效，即解决报文插队的问题 ACK：确认号是否有效 PSH：提示接收端应用程序立刻从TCP缓冲区将数据读走（接收方的上层尽快取走） RST：对方要求重新建立连接（复位报文段） SYN：请求建立连接，与ACK合用以建立TCP连接 FIN：通知对方，本端要关闭了。称携带FIN标识的为结束报文段 16位窗口大小：可以理解成自己所能提供的缓冲区大小（填上自己的，给对方看，让对方根据这个数值来设置要发给自己的被滑动窗口传输的数据量）。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲 16位校验和：CRC校验。接收端不通过则认为数据有问题。此处的校验和不光包括TCP首部，也包括TCP数据部分 16位紧急指针：标识哪部分数据是紧急数据 40字节头部选项：暂时忽略 连接管理机制TCP连接包括建立和拆除两个过程。TCP使用3次握手协议来建立连接。连接可以由任何一方发起，也可以由双方同时发起。一旦一台主机上的TCP软件已经主动发起连接请求，运行在另一台主机上的TCP软件就被动地等待握手。 建立连接设主机B运行一个服务器进程，它先发出一个被动打开命令，告诉它的TCP要准备接收客户进程的连续请求，然后服务进程就处于听的状态。不断检测是否有客户进程发起连续请求，如有，作出响应。 设客户进程运行在主机A中，他先向自己的TCP发出主动打开的命令，表明要向某个IP地址的某个端口建立运输连接，过程如下： ​ 1）主机A的TCP向主机B的TCP发出连接请求报文段，其首部中的同步比特SYN应置1，同时选择一个序号x，表明在后面传送数据时的第一个数据字节的序号是x。 ​ 2）主机B的TCP收到连接请求报文段后，如同意，则发挥确认。在确认报文段中应将SYN置为1，确认号应为x+1，同时也为自己选择一个序号y ​ 3）主机A的TCP收到此报文段后，还要向B给出确认，其确认号为y+1 ​ 4）主机A的TCP通知上层应用进程，连接已经建立，当主机B的TCP收到主机A的确认后，也通知上层应用进程，连接建立。 释放连接 在数据传输完毕之后，通信双方都可以发出释放连接的请求。释放连接的过程为如上图所示： ​ 1）数据传输结束后，主机A的应用进程先向其TCP发出释放连接请求，不在发送数据。TCP通知对方要释放从A到B的连接，将发往主机B的TCP报文段首部的终止比特FIN置为1，序号u等于已传送数据的最后一个字节的序号加1。 ​ 2）主机B的TCP收到释放连接通知后发出确认，其序号为u+1，同时通知应用进程，这样A到B的连接就释放了，连接处于半关闭状态。主机B不在接受主机A发来的数据；但主机B还向A发送数据，主机A若正确接收数据仍需要发送确认。 ​ 3）在主机B向主机A的数据发送结束后，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特置为1，并使其序号w等于前面已经传送过的数据的最后一个字节的序号加 1，还必须重复上次已发送过的ACK=u+1。 ​ 4）主机A对主机B的连接释放报文段发出确认，将ACK置为1。这样才把从B到A的反方向连接释放掉，主机A的TCP再向其应用进程报告，整个连接已经全部释放。 123456789101112131415161718可以根据上图看到客户端以及服务端状态变化：客户端状态变化：CLOSED-&gt;SYN_SENT:客户端调用connect,发送同步报文段SYN_SENT-&gt;ESTABLISHED:connect调用成功，则进入ESTABLISHED状态，开始读写数据ESTABLISHED-&gt;FIN_WAIT_1：客户端主动调用close时，向服务器发送结束报文段，同时进入FIN_WAIT_1FIN_WAIT_1-&gt;FIN_WAIT_2:客户端收到服务器对结束报文段的确认就进入FIN_WAIT_2，开始等待服务器的结束报文段FIN_WAIT_2-&gt;TIME_WAIT:客户端收到服务器发来的结束报文段，进入TIME_WAIT,并发出LAST_ACKTIME_WAIT-&gt;CLOSED:客户端要等待一个2MSL（Max Segment Life，报文最大生存时间）的时间才进入CLOSE状态服务端状态变化：CLOSED-&gt;LISTEN:服务端调用listen后进入LISTEN状态，等待客户端连接LISTEN-&gt;SYN_RCVD:一旦监听到客户端连接请求（同步报文段），就将该连接放入内核等待队列中，并向客户端发送 SYN确认报文SYN_RCVD-&gt;ESTABLISHED:服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，可以进行读写数据了ESTABLISHED-&gt;CLOSE_WAIT:当客户端主动关闭连接（调用close），服务器会收到结束报文段，服务器返回确认报文 段并进入CLOSE_WAITCLOSE_WAIT-&gt;LAST_ACK:进入CLOSE_WAIT后说明服务器准备关闭连接（处理完之前的数据）；当服务端真正调用close 关闭连接时，会向客户端发送FIN，此时服务器进入LAST_ACK状态，等待最后一个ACK到来（这个 ACK是客户端确认收到了FIN）LAST_ACK-&gt;CLOSED:服务器收到了对FIN的ACK，彻底关闭连接 理解TIME_WAIT上边提到一个名词–&gt;TIME_WAIT,那么什么是TIME_WAIT？ 首先我们可以通过如下测试：启动server，再启动一个client，然后使用Ctrl+C使server终止，这时立马运行server结果是： 这是因为，虽然server的应用程序终止了，但是TCP协议层的连接还没有完全断开，因此不能监听到同样的server端口。 12TCP协议规定，主动关闭的一方要处于TIME_WAIT状态，等待两个MSL的时间才能回到CLOSED状态。我们使用Ctrl+C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。 TIME_WAIT为什么是2MSL呢123MSL是TCP报文的最大生存时间，因此TIME_WAIT持续在2MSL时间的话:1.保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失（否则服务器立即重启就会收到来自上一个进程迟到的数据，而这个数据可能是错误的）2.在理论上保证最后一个报文可靠到达（假设最后一个ACK丢失了，那么服务器会重发一个FIN。这时候虽然客户端进程不在了，但是TCP连接还在，仍然可以重发LAST_ACK） ​ 此时会出现一个新的问题：如果服务器需要处理大量的客户端连接，但是这些连接的生存周期很短，这个时候如果由服务器来主动关闭连接清除不活跃连接就会导致服务器上产生大量TIME_WAIT连接，从而导致服务器的端口不够用无法处理新的连接。 1234567如何解决这个问题呢？ 在server代码的socket()和bind()调用之间插入如下代码： int opt = 1; setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt)); 引入了setsockopt()函数。使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统之进程]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这一章我们主要介绍进程的状态，了解进程的状态有助于我们分析进程在系统中的各种作用等。进程的调度算法，进程的调度算法可以让我们看到内核是如何设计出一套注重效率并且兼顾公平的算法，内核如何为不同的进程分配资源等，帮助我们加深对于进程相关知识的了解。 进程的状态首先我们要知道进程虽然是占有CPU资源的可是就像人不能一直工作一样，进程也不能一直占用CPU资源，同时我们还要考虑并发问题等，具体原因有： 1.进程可能需要等待某种外部条件的满足，在满足条件之气那无法继续执行，在这种情况下占用CPU是对资源的浪费 2.linux是多用户多任务的操作系统，可能同时存在多个可以运行的进程，进程个数可能远远多于CPU个数，一个进程始终占有CPU对于其他进程来说不公平 3.linux支持软实时，实时进程的优先级高于普通进程，实时进程之间也有优先级的差别，软实时进程进入可运行状态的时候，可能会发生抢占，抢占当前运行的进程。 接下来我们具体说一下进程的状态，进程的状态一共有七种： 12345678910111213141516171819202122232425262728293031323334353637383940414243可运行状态 首先是可运行状态，这个状态不一定占用CPU资源，这个状态细分可以分成两个状态，正在运行与准备状态，处于准备状态意味随时可以运行，只不过由于CPU资源有限暂时没有运行 处于可运行状态的进程是进程调度的对象，如果进程并不处于可运行状态，进程调度就不会选择它投入运行，在Linux中每一个CPU都有它的运行队列，事实上还不止一个，根据调度类别不同可运行状态的进程位于不同的队列，如果是实时进程落入实时调度类的队列中，普通进程落入公平调度类的队列中，这样进程调度器就可以根据一定的算法从运行队列上挑选合适的进程来使用CPU资源 处于可运行状态的进程可能正在执行用户态的代码（比如计算排序等），也有可能在执行内核态的代码（类似IO等）Linux的time命令统计了三种时间，分别是实际时间，用户CPU实际以及系统CPU时间，其中最让我们产生误会的是很多人误以为 实际时间就等于用户CPU时间加系统CPU时间。 其实比如我们要是多核处理的话后者总和就会大于前者，要是我们一直陷入阻塞的话就会产生前者大于后者总和，我们根据这种时间分配分为计算密集型进程与IO密集型进程，前者是充分利用了多处理器并行的优势，后者多核并行优势并不明显。 可中断睡眠状态与不可中断睡眠状态 进程不是总处于可运行状态的，有的进程需要与慢设备打交道，比如进程和磁盘进行交互，相关的系统调用消耗的时间是非常长的，进程需要等待这些操作完成才能执行下来的指令。 在这种情况下占用CPU资源就很浪费了，所以这个时候内核将进程的状态改变为其他状态，将其从CPU的运行队列中移除，同时调度器选择其他的进程来使用CPU资源。 LINUX有两种睡眠状态，可中断睡眠与不可中断睡眠状态，可中断睡眠是指在睡眠中可以被唤醒，其中两种方式可以唤醒可中断睡眠，当收到没有被屏蔽的信号的时候会唤醒，当等待的事情发生了也会被唤醒，可是对于不可中断睡眠来说，只有一种情况就是等待的事情发生了才会醒来，不然就会一直陷入等待，KILL信号也不能将他唤醒。 很多人认为在vfork创建子进程的时候，子进程调用exec函数或退出之前，父进程始终处TASK_UNINTERRUPTIBLE状态，其实这个说法是错误的，因为很明显，父进程可以轻易的被信号杀死，这证明并不是处于不可中断睡眠状。 TASK_KILLABLE状态 事实上在内核2.6.25版本引入了一种新的状态即TASK_KILLABLE状态，这个状态是可中断睡眠与不可中断睡眠的综合版本，除了杀死这个进程的信号要进行唤醒处理之外，其他的信号一概不管。 等待队列 进程无论是哪一种睡眠状态，有一个数据结构是绕不开的，那就是等待队列，单反进程要进行休眠，必然是等待某个资源或者某个事件，内核必须想办法将进程和它等待的资源关联起来，当等待的资源可用或等待的事件已经发生的时候，可以及时的唤醒相关进程，内核采用的办法是等待队列 内核用双向链表来表示等待队列，每一个等待队列都可以用等待队列头来标识，内核中提供了wait_queue和add_queue_exclusive两个函数来吧等待队列元素添加到等待队列头部的双向链表 可是这里有一个新的问题： 如果存在多个进程在等待同一个满足条件或同一个事件发生，那么当条件满足的时候，应该吧所有进程一并唤醒还是只唤醒一个或几个进程呢。 应该是具体问题具体分析，有的时候我们需要唤醒所有进程，有的时候我们只足够一个进程来获取资源，可是我们要是全部唤醒的话就会发生除了获取到资源的进程外其他资源被唤醒后再次进入睡眠这个也被叫做惊群效应。 暂停状态与跟踪状态 暂停状态是一种较为特殊的状态，暂停后不能安装新的信号处理函数，直到收到CIGCONT后才会继续执行程序。 跟踪状态是指进程会停下来等待跟踪他的进程的操作，比如我们gdb调试的时候加断点就会进入暂停 僵尸状态与死亡状态 严格来说这不是进程的状态，进程与程序的区别就在于进程是正在被执行，而这两种都已经死亡，僵尸状态我们以前提过就是子进程退出后内核发送SIGCLD信号给父进程，父进程要是默认忽略没有等待子进程那么子进程的部分信息没办法进行回收子进程就会进入僵尸状态，死亡状态时间非常短，进程退出的时候就会进入死亡状态，我们一般观察不到。 进程调度设计原则进程调度是任何一个现代擦欧总系统都要解决的问题，也是我们这篇博客的重点，首先我们要从知道只有TASK_RUNNING状态的进程才可以进入调度队列被调度。 Linux是多任务的操作系统，多任务操作系统可以分为两类：抢占式和非抢占式，在非抢占式的操作系统中只有一个进程自己主动退出让出CPU的使用权其他进程才可以使用CPU，所以非抢占式也被叫做合作型多任务。 可是对于操作系统设计进程调度来说，合作型多任务没有优先级的概念，很多需要立即执行的进程反而长时间陷入等待，所以大多数操作系统是抢占式的，Linux也不例外，抢占式多任务由操作系统来决定进程调度，对于操作系统来说，面对不同类型的进程设计一个全面考虑的调度算法是很不容易的。 他要做到以下的几点： 12345678910111213141516171819公平:每一个进程都可以获得调度的机会，不能出现长时间不被调度的情况 良好的调度延迟：尽量确保进程在一定的时间范围内，总可以获得调度的机会 差异化：允许重要的进程获得更多的执行时间 支持软实时机制：软实时进程比普通的进程有更高的优先级 负载均衡：多个CPU要分配均衡，不能出现一些很闲一些很忙的情况 高吞吐量：单位时间内处理的进程个数尽可能多 简单高效：调度算法要高效，不能在调度上花费太多时间 目前Linux采用的是每个CPU都有自己的运行队列，每个CPU去自己的运行队列中选择进程，这样就可以降低竞争，这种方案还有一个好处就是缓存重利用。 某个进程位于它所属CPU的运行队列中，经过多次调度之后，内核区域选择相同的CPU去执行该进程，这种情况上次运行的变量很可能仍然处于CPU的缓存之中，提升了效率。 可是这样有一个问题，可能会负载不均衡，出现有的CPU的运行队列中有很多进程而有的CPU运行队列中没有进程的情况，为了解决这个问题，Linux提出了load_balance，它的作用就是在一定时机下，通过将任务从一个CPU的运行队列迁移到另一个CPU的运行队列中，实现负载均衡。 那么进程调度具体是干了些什么呢，其实说白了就是挑选下一个执行的进程，如果下一个被调度的进程和当前进程不是一个进程，就执行上下文切换。 Linux是抢占式内核，从内核2.6开始不仅支持用户态抢占，也支持内核态抢占，可抢占内核的优势在于何以保证系统的响应时间，当高优先级任务一旦就绪，总能及时得到CPU的控制权，但是很明显，内核抢占不能随意发生，某些情况下不能发生内核抢占，为了可以确定什么时候可以发生抢占，内核为每一个进程引入了一个preempt_count计数器，数值为0表示可以发生抢占，数值为1代表不能发生抢占。 preempt_count设置了很重要的一个标志位，即PREEMAT_ACTIVE，该标志为用来标记是否正在发生内核抢占，设置了之后就代表preempt_count不再为0，同时不允许再次抢占，PREEMAT_ACTIVE有一个很重要的作用就是设置了这个标志位的进程那么即使不处于RUNNING状态内核也不能将他从运行队列中剔除。 因为有一种情况是当前占用CPU的进程刚刚将自己设置为睡眠状态并且打算等待信号，可是这个时候发生了抢占，这个时候他就已经不是运行状态了，按道理说要将它从运行队列中剔除，可是如果我们真的剔除了那么他将永远睡眠再也不会醒来。正确的做法是将他再次放入运行队列，他就还有机会操作CPU资源就还有机会被唤醒。 调度类在选择下一个占用CPU的进程之前，内核会先根据调度类来更些一些数据，用来保证下一个调度的优先级最高。linux下一共有下面几种调度类： 12345671.stop_sched_class 停止类 2.rt_sched_classs 实时类 3.fair_sched_classs 完全公平调度类 4.idle_sched_classs 空闲类 这四种调度类是根据优先级顺序排布的，停止类具有最高的优先级，与之对应的空闲类有最低的优先级，挑选下一个进程的时候就先从停止类里面选择，没有的话从实时类选，以此类推。 ​ 优先级最高的停止类进程，主要用户多个CPU之间的负载均衡和CPU的热拔插，他所作的事情就是停止正在运行的CPU，以进行任务的迁移或拔插CPU，优先级最低的空闲类负责将CPU置于停机状态，直到中断将其唤醒，这两种类都是为了实现CPU调度性能的功能类，真正和应用层有关系的是实时类和完全公平调度类。 普通进程的优先级除非Linux用在一些特殊领域，不然Linux上的进程都是完全公平调度类，Linux是多任务系统，系统不能让一个进程始终占据CPU资源，那么如何给每一个进程分配多大的时间片就是一个很值得思考的问题。 ​ Linux实现完全公平调度类使用了一种动态时间片的算法，他给每一个进程分配使用CPU的时间比例，进程调度设计上，有一个很重要的指标是调度延迟，也就是保证每一个可运行的进程都至少运行一次的时间间隔。 ​ 比如我们调度延迟是20毫秒，正在运行的进程一共两个，那么每一个进程运行的时间片就是10毫秒，调度延迟可以让每一个进程都有机会占用CPU进程，可是产生了新的问题，要是我们的调度延迟是10毫秒但是正在运行的进程100个的话，那么根据调度延迟来说每一个进程只能分0.1毫秒的时间片，这显然什么都干不了。 ​ 为了应对这种情况，完全公平调度提供了另一种调度方法，调度最小颗粒，这个就是说任意进程所运行的时间片都有一个基准的最小值，不能小于这个最小值，对于这两种调度方法，进程规定了一个最大活动进程数目，最大活动数目等于调度延迟除以调度颗粒。 ​ 也就是说当当前进程个数小于最大活动数的时候，分得的时间片大于最小颗粒，就用延迟调度，当进程个数太多导致大于最大活动数的时候，分得的时间片小于调度最小颗粒，就按照调度最小颗粒的值来指定时间片。 ​ 到目前为止，我们所有的讨论都基于运行对立额上所有的进程都有相同的优先级，可是事实并非如此，有些任务的优先级高，理应获得更多的运行时间，考虑到这种情况，完全公平调度又引入了优先级的概念。 ​ 完全公平调度是通过引入调度权重来实现优先级的进程之间按照权重的比例，分配CPU时间，分配给进程的运行时间=调度周期*进程权重/运行队列所有进程权重之和。 ​ Linux下每一个进程都有一个nice值，该值的取值范围是[-20，19]nice值越高代表优先级越低，默认的优先级是0. weight=1024/（1.25^nice_value）。 普通进程的组调度1假如一个运行队列上一共有四个进程，这四个进程优先级相同，那么根据调度延迟以及调度最小颗粒，每一个进程分25%的时间片，可是如果其中三个进程是A组的，最后一个进程是B组的那么就会造成A组分得了大量的时间片而B组分的很少的情况，针对这种情况，内核先实现组间平衡，再实现组内平衡，也就是说B组的进程最后可以分得50%的时间片而A组的三个进程各自分得16.7%的时间片。 实时进程的调度​ 对于普通进程来说，完全公平调度已经可以实现足够好的性能以及响应体验了，但是对于实时性要求更高的进程来说还是不够，严格来说实时系统可以分为两类，硬实时进程和软实时进程，硬实时进程对于响应时间的要求非常严格，必须保证在一定的时间内完成超出相应事件就会失败并且有很严重的后果，比如军用武器系统，航空航天系统里面就很多硬实时进程。 ​ 软实时是硬实时的弱化版本，虽然也要求响应时间，可是超出了规定时间并不会有很严重的后果，比如视频处理，撑死影响用户体验，发生视频丢帧什么的（虽然我觉得视频丢帧也超级重要）。 实时调度策略与优先级Linux针对实时调度类也提供了两种调度策略，先进先出与时间片轮转策略，无论你使用哪一种策略都会高于前面的公平调度进程。 在linux中一共提供了140个优先级等级，0到99都是属于实时调度类的，100到139是属于完全公平调度类的，完全公平调度类的初始值就是120，所以我们知道不管如何调整nice值也不会使它跨类。 内核为这99个等级维护了99个队列，当要选下一个进程的时候就挨个去这些队列里边找，同时内核还用一个位图来表示哪个队列有运行的程序。 先进先出的调度策略没有时间片的概念，只要没有更高优先级的进程就绪，那么就会一直执行当前最高优先级的进程，除非自动放弃CPU资源或者进程终止。 时间片轮转的调度策略就是在当前相同优先级的优先级队列中所有进程平分时间片。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础（一）]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据传输（ (不)同主机上的进程间同信）协议：(通信双方的一个数据格式协议)网络中主机之间进行通信也必须使用相同的协议（相同的一个光电信号格式） 计算机如何传播数据—-光电波信号在网络中因为主机设备的生产厂商很多，每个厂商如果都使用自己的协议进行通信，那么将导致网络上主机间无法正常通信，于是设计了一个标准的协议 网络间的数据传输就必须使用同一个标准协议 ——-网络通信协议 在网络通信中，因为应对场景各有不同，因此协议也相对特别复杂，为了使用起来更加方便，因此就有了协议的封装/分层。 协议的封装/分层：按照各个协议的不同功能以及不同的应对场景对不同的协议进行了分层，在特定的环境下如果协议的分层清晰明了，那么使用/替换起来就更加方便 OSI网络互联七层参考模型：优点：1.将服务，接口和协议明确区分开来 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP五层模型：TCP/IP五层模型：TCP/IP指的是一个协议簇，因为TCP协议和IP协议是最典型的两个协议，因此这个协议簇就拿这两个协议名字进行命名了 应用层 :负责应用程序间的数据沟通 http/https ftp 传输层（内部完成）：负责端与端之间的数据传输（进程与进程间）TCP/UDP 网络层:负责地址管理和路由选择 IP (路由器) 数据链路层:负责相邻设备节点间的数据传输 以太网协议 交换机 物理层：负责光电信号的传输 以太网协议 集线器 数据的传输流程：1.不同的协议层对数据包有不同的称谓，在传输层叫做段，在网络层叫做数据报，在链路层叫做帧 2.应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部，称为封装 3.首部信息中包含了一些类似于首部有多长，载荷有多长，上层协议是什么等信息 4.数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，根据首部中的“上层协议字段”将数据交给对应的上层协议处理 套接字编程——–原始的网络socket编程IP地址：唯一定位网络上的主机（无符号四个字节的整数——uint32_t） 端口：标识一台主机上的进程（无符号两个字节的数据 uint16_t ,0~65535） 进程的标识为什么不用PID？ 因为PID会随着进程的创建改变的 sip+sport+dip+dport+proto 五元组 网络字节序：大小端 大端字节序：低地址存高位 0x01 02 03 04 uchar buf[4] 01 02 03 04 小端字节序：低地址存低位 uchar buf[4] 04 03 02 01 所以不同字节序主机之间进行数据传输，将造成数据的逆序，也就是得不到人家真正发送的数据。因此，约定了在网络间进行通信时必须使用大端字节序—-网络字节序，也就意味着如果我们的主机时小端字节序，那么通信时就需要对数据逆序，但是并不是所有数据都需要逆序，主要针对在内存中存储时，占据字节大于1个字节的数据（short,int,float,double,long等,针对这些类型的是数据，因为在内存中的存储跟展示顺序刚好相反，而发送时按字节发送对方按字节接收，那么如果对方时大端，因为低地址存高位，因为存储顺序和使用顺序完全相同，导致数据跟实际想发送的数据顺序刚好相反，因此需要进行字节逆序转换） 主机字节序：当前主机的字节序—–大小端不一定，取决于CPU的架构 x86（小端） MIP5（大端） RISC-V 网络套接字编程：（主要说的时传输层的TCP/UDP） 因为传输层有两个传输协议，所以必须选择其一进行数据传输，那么如何选择？ 答：TCP：面向连接，可靠传输，字节流服务 优点：可靠传输，并且传输灵活 缺点：传输速度低，数据粘包 UDP：无连接，不可靠，面向数据报 优点：传输数据快，无粘包 缺点：不可靠 针对数据安全性要求高的场景（文件传输）：使用TCP保证数据的可靠 安全性要求不是很高但是实时性要求高的场景（视频传输）：使用UDP保证传输速度 socket套接字编程： 网络编程涉及到对网卡的操作，因此操作系统就提供了一套接口—socket接口 网络编程中分了两个端：客户端程序和服务端程序（在网络编程中，客户端是主动的一方，并且客户端必须知道服务端的地址信息ip+port，而服务端需要在这个指定的地址等着） UDP编程步骤： 服务端： 创建套接字（建立网卡与进程之间的关系） 为套接字绑定地址信息（声明去网卡接收数据时找所需要的正确数据） 接收/发送数据 关闭套接字 客户端：创建套接字 ​ 绑定（由操作系统自己完成，不主动绑定） ​ 发送/接收数据 ​ 关闭套接字 服务端必须绑定地址，因为服务端是被动的一端，必须告诉别人需要将数据发送到哪个地址哪个端口，因此自己就必须接收这个地址这个端口的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811.int socket(int domain, int type, int protocol);domain：地址域 AF_INET IPV4type：套接字类型SOCK_STREAM 流式套接字 TCPSOCK_DGRAM 数据报套接字 UDPpro： 协议类型IPPROTO——TCP 6 TCP协议IPPROTO——UDP 17 UDP协议 返回值：非负整数（套接字描述符） 失败：-12.int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);sockfd：套接字描述符addr：地址信息addrlen：地址信息长度返回值：成功：0 失败：-1uint16_t htons(uint16_t hostshort);将一个短整型（16位）数据从主机字节序转换成网络字节序in_addr_t inet_addr(const char *cp);将点分十进制的字符串IP地址转换为网络字节序的地址INADDR_ANY：只能用于服务端（0.0.0.0）3.ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);sockfd：套接字描述符buf：要发送的数据len：发送的数据长度flags：发送标志 一般给0，默认阻塞MSG_PEEK 接收数据后数据不会立即从缓冲区删除场景：探测型获取数据src_addr：发送端的地址信息addrlen：地址信息长度返回值：实际读取到的字节长度assign：从一个字符串中拷贝指定长度的数据到string中ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);sockfd：套接字描述符buf：要发送的数据len：发送的数据长度flags：发送标志 一般给0，默认阻塞dest_addr：数据要发送到的对端地址信息addrlen：地址信息长度返回值：实际发送的数据长度 失败：-14.close(sockfd) 关闭套接字释放资源]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[对象之间可以进行复制操作，包括采用拷贝构造函数的方式用一个对象去构造另一个对象（用一个对象的值初始化一个新的构造的对象），如同指针的复制一样，对象复制也分为浅复制和深复制 对象浅拷贝： 两个对象之间进行复制时，若复制完成后，他们还共同使用着某些资源（内存空间），其中一个对象的销毁会影响另一个对象（动态顺序表） 如果没有显式提供拷贝构造函数与赋值运算符重载，编译器会生成一个默认的拷贝构造函数和运算符重载（默认为位的拷贝，将一个对象中的内容原封不动的拷贝到到另一个对象中。如果类中涉及到资源管理，则会使得多个对象在底层共用同一块资源，在销毁对象时，就会导致一份资源释放多次引起程序崩溃） 如果一个类中涉及到资源，该类必须显式提供拷贝构造含糊，赋值运算符重载函数，析构函数 //类似系统生成的默认拷贝构造函数的方式 ​ //值的拷贝方式—–内存的拷贝 ​ //后果：多个对象共用同一份资源，在销毁时同一份资源被释放多次而引起程序的崩溃 12345String(const String&amp; s) :str(s.str) //当前对象的指针和s里的字符串共用同一段空间 &#123;&#125; ​ 对象深拷贝： 当两个对象之间进行复制时，若复制完成后，它们不会共享任何资源（内存空间），其中一个对象的销毁不会影响另一个对象 ​ 123456789String(const String&amp; s) :str(new char[strlen(s.str) + 1]) //先分配一段空间 &#123; strcpy(str,s.str); &#125; 此时查看监视，发现s1与s2地址空间并不一样，不会产生内存泄露问题，也可以正常析构销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404#include&lt;assert.h&gt;#include&lt;iostream&gt;using namespace std;#if 0 浅拷贝问题的String类class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; //assert(str); //断言检测是否为空 if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); /* if(nullptr == str) &#123; //_str = new char //分配一个字节的空间,但在下边析构时需要与delete匹配起来使用，为了方便，将其设为以下形式 _str = new[1] char; *_str = &quot;\0&quot; &#125; else &#123; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; */ &#125; //类似系统生成的默认拷贝构造函数的方式 //值的拷贝方式-----内存的拷贝 //后果：多个对象共用同一份资源，在销毁时同一份资源被释放多次而引起程序的崩溃 String(const String&amp; s) :_str(s._str) //当前对象的指针和s里的字符串共用同一段空间 &#123;&#125; //类似系统生成的默认的赋值运算符重载的方式 //问题：1.内存泄露 // 2.与拷贝构造函数类似 String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; _str = s._str; return *this; &#125; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void TestString()&#123; String s1(&quot;hello&quot;); String s2(s1); //用s1拷贝构造s2，因为没有自己给出拷贝构造函数，系统会默认使用类生成的拷贝构造函数进行值的拷贝（浅拷贝）,销毁期间会对一段资源销毁两次产生程序而崩溃 String s2 = s1; //此时会看到s2本身有一个地址空间，但是在赋值时完全将s1中的东西拷贝，使得s2本来的空间找不到了，产生内存泄漏&#125;#endif#if 0使用深拷贝进行处理 传统方式class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; //assert(str); //断言检测是否为空 if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); /* if(nullptr == str) &#123; //_str = new char //分配一个字节的空间,但在下边析构时需要与delete匹配起来使用，为了方便，将其设为以下形式 _str = new[1] char; *_str = &quot;\0&quot; &#125; else &#123; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; */ &#125; String(const String&amp; s) :_str(new char[strlen(s._str) + 1]) //先分配一段空间 &#123; strcpy(_str,s._str); &#125; String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; /* 释放旧空间，开辟新空间，再进行字符串拷贝 delete[] _str; //因为先释放了原来空间，如果开辟新空间失败了，那么会造成影响 _str = new char[strlen(s._str) + 1]; strcpy(_str,s._str); */ char* pStr = new char[strlen(s._str) + 1]; strcpy(_str,s._str); delete[] _str; //释放掉旧空间 _str = pStr; &#125; return *this; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1);&#125;int main()&#123; Test(); return 0;&#125;#endif#if 0现代版写法，代码较简洁class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; String(const String&amp; s)//注意！本编译器下此时_str没有进行初始化，放的是一个随机值，所以在释放strTemp时出错，所以需要给一个初始值 :_str(nullptr) &#123; String strTemp(s._str); swap(_str,strTemp._str); &#125; /* String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; String strTemp(s); swap(_str,strTemp._str); &#125; return *this; //当前对象用的是临时对象的空间，出了作用域销毁临时对象，实际是将当前对象的地址空间释放了 &#125; */ String&amp; operator=(String s) &#123; swap(_str,s._str); return *this; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; s3 = s2; //此时实际是临时对象给s3赋值的&#125;int main()&#123; Test(); return 0;&#125;#endif#if 0class String&#123;public: String(const char* str = &quot;&quot;) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); _count = 1; &#125; String(String&amp; s) :_str(s._str) ,_count(++s._count) &#123;&#125; ~String() &#123; if(0 == --_count &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str; int _count; //每个对象中均有一份，一个对象修改了其他对象不知道&#125;;#endif/*static也不可以，是类中所有对象共享的class String&#123;public: String(const char* str = &quot;&quot;) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); _count = 1; &#125; String(String&amp; s) :_str(s._str) &#123; ++_count; &#125; ~String() &#123; if(0 == --_count &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str; static int _count; //所有对象共享的，但资源有可能会有多分，每调用一次构造就将_count置为1了，不能针对多份资源，如 String s3;&#125;;int String::_count = 0;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; //此时会出现问题，到这里时_count重新被置为1，导致只能将s3释放而无法释放s1和s2&#125;int main()&#123; Test(); return 0;&#125;*/#if 0//写时拷贝（COW copy on write）:浅拷贝+引用计数+在向对象写内容时，是否需要给当前对象独立空间class String&#123;public: String(const char* str = &quot;&quot;) :_pCount(new int(1)) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; String(String&amp; s) :_str(s._str) ,_pCount(s._pCount) &#123; ++*(_pCount); &#125; String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; if(0 == --(*_pCount) &amp;&amp; _str) //检测拷贝以后自己的资源需不需要释放 &#123; delete[] _str; _str = nullptr; delete _pCount; _pCount = nullptr; &#125; //与被拷贝的资源共享资源 _str = s._str; _pCount = s._pCount; //新资源计数+1 ++(*_pCount); &#125; return *this; &#125; char&amp; operator[](size_t index) //返回引用是因为有可能返回后作为左值 &#123; if(*_pCount &gt; 1) &#123; String str(_str); this-&gt;Swap(str); &#125; return _str[index]; &#125; const char&amp; operator[](size_t index)const &#123; return _str[index]; &#125; ~String() &#123; if(0 == --(*_pCount) &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; delete _pCount; _pCount = nullptr; &#125; &#125; void Swap(String&amp; s) &#123; swap(_str,s._str); swap(_pCount,s._pCount); &#125;private: char* _str; int* _pCount; &#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; //s3 = s1; s1 = s3; s1[0] = &apos;H&apos;; //此时一改变会全改变，s1,s2,s3共用一份资源&#125;int main()&#123; return 0;&#125;#endif]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[如何实现一个通用的函数呢？（如针对不同的参数类型均可） 使用函数重载可以实现，但是使得代码复用率和可维护性比较低 泛型编程： 编写与类型无关，与使用场景无关的通用代码，使得代码可以复用 模板： 函数模板：是一个函数家族，与类型无关，使用时才被参数化，根据实参类型产生函数的适用版本 template //模板参数列表 可以使用template ，不可以使用struct T1 _Add(T1 left,T2 right) //函数模板 { ​ return left + right; } 实例化： 隐式实例化： 编译器根据实参推演模板参数的实际类型 显示实例化：函数名和后加&lt;&gt;指定参数实际类型 匹配原则： 1.优先调用自己写的模板函数 2.模板函数不允许自动类型转换，普通函数可以自动类型转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#pragma once#include&lt;assert.h&gt;#include&lt;iostream&gt;using namespace std;#if 0//不是一个真正的函数template&lt;class T&gt; //模板参数列表 可以使用template&lt;typename T&gt; ，不可以使用struct T _Add(T left,T right) //函数模板&#123; return left + right;&#125;template&lt;class T&gt;void PrintfArray(T array,int size) //数组会自己转换类型&#123; cout&lt;&lt;typeid(array).name() &lt;&lt;endl; int i = 0; for(i=0;i&lt;size;i++) &#123; cout&lt;&lt; array[i] &lt;&lt; &quot; &quot;; cout&lt;&lt;endl; &#125;&#125;int main()&#123; int array[] = &#123;1,2,3,4,&#125;; char str[] = &quot;hello&quot;; PrintfArray(array,sizeof(array)/sizeof(int)); PrintfArray(str,strlen(str)); //隐式实例化---不会进行隐式的类型转化，需要用户自己来强转/ cout&lt;&lt; _Add(1,2) &lt;&lt;endl; //根据实参类型来进行类型推演生成处理具体类型的函数 cout&lt;&lt; _Add(1,(int)2.0) &lt;&lt;endl; //但是面对参数为不同类型时无法判断如何输出，需要对参数进行处理，如强转类型 //显式实例化 _Add&lt;int&gt;(1,2.2); _Add&lt;&gt;(1,2); //隐式实例化 return 0;&#125;#endif#if 0template&lt;class T&gt;class Seqlist&#123;public: Seqlist(int capacity = 10) :_Data(new T[capacity]) ,_capacity(capacity) ,_size(0) &#123;&#125; //拷贝构造：Seqlist(const Seqlist&lt;T&gt;&amp; s); //赋值运算符重载：Seqlist&lt;T&gt;&amp; operator = (const Seqlist&lt;T&gt;&amp; s) void PushBack(const T&amp; data) &#123; _CheckCapacity(); _Data[_size++] = data; &#125; void PopBack() &#123; if(_size != 0) --_size; &#125; //访问任意位置 T&amp; operator[](size_t index) //可能会修改s[i]中的元素 &#123; assert(index &lt; _size); return _Data[index]; &#125; //因为const类型的对象不能调用普通函数，这里是const对象访问 const T&amp; operator[](size_t index) const &#123; assert(index &lt; _size); return _Data[index]; &#125; //访问第一个元素 T&amp; Front() &#123; return _Data[0]; &#125; const T&amp; Front()const &#123; return _Data[0]; &#125; //访问最后一个元素 T&amp; Back() &#123; return _Data[_size-1]; &#125; const T&amp; Back()const &#123; return _Data[_size-1]; &#125; size_t Size() const &#123; return _size; &#125; size_t Capacity() const &#123; return _capacity; &#125; void Clear() &#123; _size = 0; &#125; ~Seqlist();private: void _CheckCapacity() &#123; if(_size == _capacity) &#123; size_t newCapacity = (_capacity&lt;&lt;1); //申请空间 T* Temp = new T[newCapacity]; //拷贝元素 memcpy(Temp,_Data,_size*sizeof(T)); //释放旧空间 delete[] _Data; //替换新空间 _Data = Temp; _capacity = newCapacity; &#125; &#125;private: T* _Data; size_t _capacity; size_t _size;&#125;;template&lt;class T&gt;Seqlist&lt;T&gt;::~Seqlist()&#123; if(_Data) &#123; delete[] _Data; _Data = nullptr; _capacity = 0; _size = 0; &#125;&#125;void TestSeqlist()&#123; Seqlist&lt;int&gt; s1; Seqlist&lt;double&gt; s2; Seqlist&lt;char&gt; s3; s1.PushBack(1); s1.PushBack(2); s1.PushBack(3); s1.PushBack(4); s1[0] = 6; cout&lt;&lt; s1.Size()&lt;&lt;endl; cout&lt;&lt; s1.Front()&lt;&lt;endl; cout&lt;&lt; s1.Back()&lt;&lt;endl; s1.Clear(); cout&lt;&lt;s1.Size()&lt;&lt;endl;&#125;#include&lt;string&gt;void Test()&#123; Seqlist&lt;string&gt; s; s.PushBack(&quot;0000&quot;); s.PushBack(&quot;1111&quot;); s.PushBack(&quot;2222&quot;); s.PushBack(&quot;3333&quot;); s.PushBack(&quot;4444&quot;); s.PushBack(&quot;5555&quot;); s.PushBack(&quot;6666&quot;); s.PushBack(&quot;7777&quot;); s.PushBack(&quot;8888&quot;); s.PushBack(&quot;9999&quot;);&#125;int main()&#123; //TestSeqlist(); Test(); return 0;&#125;#endif]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存管理]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[父子进程之SIGCHLD]]></title>
    <url>%2F2018%2F11%2F11%2F%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8BSIGCHLD%2F</url>
    <content type="text"><![CDATA[​ 在用wait和waitpid函数处理僵尸进程时，父进程可以阻塞等待子进程结束，也可以非阻塞的查询是否有子进程结束等待处理。但是，第一种方式父进程阻塞了就不能处理自己的工作了，而第二种父进程在处理自己的工作时还需要时不时的轮询一下，使得程序变得复杂。而在子进程终止时，会给父进程发送SIGCHLD信号，该信号的默认处理是忽略，父进程可以自定义该函数，使得父进程可以专心处理自己的工作不必关心子进程，而在子进程终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可。 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;stdlib.h&gt;void sigcb()&#123; //使用非阻塞的循环来处理SIGCHLD信号 //因为SIGCHLD信号是不可靠信号，有可能会丢失 //一旦接受到信号就处理到不能处理为止 //!=0代表一直有子程序在退出，所以一直循环，&gt;0返回子进程PID (!=0可能&lt;0，没有子进程） while(waitpid(-1,NULL,WNOHANG) != 0);//多个子进程可能会同时退出，如果同时退出了那么有些信号就会丢失，使得少处理一个信号 printf(&quot;Have a child exit!\n&quot;);&#125;int main()&#123; signal(SIGCHLD,sigcb); int pid = fork(); if(pid == 0) &#123; exit(0); &#125; //waitpid(-1,NULL,0); //避免产生僵尸子进程，但是使得父进程中后续的操作不能正常继续 while(1) &#123; printf(&quot;--------\n&quot;); sleep(1;) &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可重入函数]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不可重入函数：如果函数在不同的地方/时序进行调用，会对函数的功能逻辑造成影响 可重入函数：不管怎么调用都不会对函数内部功能/程序逻辑造成影响（局部变量） 下面具体演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 这是一个演示signal接口修改信号处理方式的demo* 信号的处理方式有三种：* 忽略* 默认* 自定义*/ #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;signal.h&gt; void sigcb(int signo) &#123; static int a= 1;//静态变量，再次进入可能会产生不是预期的结果 static int b = 1; int c = 0; a++; sleep(10); b++; c= a + b; printf(&quot;receive signo:%d---%d\n&quot;,signo,c);/* if(signo == SIGINT ) //因为可能有很多信号来调用这个函数，所以需要做出判断 &#123; &#125; else &#123; &#125; */ return; &#125; int main() &#123; // sighandler_t signal(int signum, sighandler_t handler); //signum:信号的编号 //handler：处理方式 // SIG_IGN 忽略 // SIG_DFL 默认 int i = 0; //signal(SIGINT,SIG_IGN); //提前备注，当这个信号到来时忽略它 signal(SIGINT,sigcb); //自定义方式处理 while(1) &#123; /*printf(&quot;--------------\n&quot;); kill(getpid(),SIGINT); if(++i == 3) &#123; signal(SIGINT,SIG_DFL); &#125;*/ sigcb(SIGQUIT); &#125; return 0; &#125; 运行程序时输入Ctrl+C，发现出现下边的情况： 这是为什么呢？图解如下： 不可重入函数的要点（什么函数是不可重入函数）： 1.函数内部包含有对全局性变量的修改操作 2.函数传参的参数跟其他地方共同使用同一个变量 因为这些对全局变量的操作不是原子性的，因此这些修改操作有可能同时在不同地方进行修改 一个函数是否可重入： 1.是否对全局性的数据进行修改操作（malloc是用全局链表来管理堆的） 2.这个操作是否是原子性的]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号之自定义处理]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[信号的捕捉流程：主要是针对信号的自定义处理方式 信号并不是立即处理的，而是选择一个合适的时机去处理，合适的时机就是当前程序从内核态切换到用户态的时候 注意：程序如何从用户态切换到内核态? 答：1.程序异常的时候 2.发起系统调用的时候 3.中断的时候 信号的捕捉是当我们发起系统调用/程序异常/中断当前程序从内核态运行切换到用户态，去处理这些事情，处理完毕之后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕之后再次返回内核态，判断没有信号要处理了就调用sys_sigreturn返回用户态（我们程序之前运行的位置）（就像我们课堂上布置的作业不会立即写） 注意：在使用这个接口时可能会因为该函数是库函数，而在Linux下的系统版本下会有细微差异 多是使用此函数所调用的系统调用接口sigaction 123456789int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);signum:指定给哪个信号去自定义处理方式act：新的处理方式oldact：保存新自定义之前的原本的操作 12345678910111213141516171819struct sigaction &#123;//都是信号的回调函数（取决于flags），任意指定其一 void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *);//传递信号并同时携带参数//当处理时不希望被别的信号所影响，所以使用sa_mask来指定需要暂时阻塞的信号 sigset_t sa_mask;//当flags被指定为SA_SIGINFO这个参数时回调的是sa_sigaction，否则都是调用handler int sa_flags; void (*sa_restorer)(void); &#125;; 下边是一个sigaction的使用demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 1 /* 2 * 因为signal这个接口有linux版本的差异性，因此可以使用sigaction这个接口来替代signal函数， 3 * 它的功能也是自定义信号的处理方式，并且signal函数内部也是通过sigaction来实现的 4 * 5 * 6 */ 7 8 /* struct sigaction &#123; 9 void (*sa_handler)(int);//处理函数 10 void (*sa_sigaction)(int, siginfo_t *, void *);//处理函数（当flags被指定为SA_SIGINFO这个参数时回调） 11 sigset_t sa_mask;//在处理信号时通过这个mask暂时阻塞一些信号，处理完之后还原 12 int sa_flags;//决定使用哪个处理接口 13 void (*sa_restorer)(void); 14 &#125;;*/ 15 16 17 #include&lt;stdio.h&gt; 18 #include&lt;unistd.h&gt; 19 #include&lt;signal.h&gt; 20 21 void sigcb(int signo) 22 &#123; 23 printf(&quot;rec signal:%d\n&quot;,signo); 24 &#125; 25 26 void sigcb1(int signo,siginfo_t* info,void* context)//context为预留的，不是传的参数，暂时不管它 27 &#123; 28 printf(&quot;rec signo:%d---param:%d\n&quot;,signo,info-&gt;si_int); 29 &#125; 30 31 32 int main() 33 &#123;34 struct sigaction new_act; 35 struct sigaction old_act; 36 //重新定义处理方式的信号为SIGINT SINQUIT 37 //int sigaction(int signum, const struct sigaction *act, 38 // struct sigaction *oldact); 39 //signum:信号编号 40 //act:新的处理方式 41 //oldact:保存原有的处理方式 42 43 //这个操作时一般性的更改一个信号的处理方式，sa_flags =0代表使用的回调接口为sa_handler 44 sigemptyset(&amp;new_act.sa_mask); 45 new_act.sa_flags = 0; 46 new_act.sa_handler = sigcb; 47 sigaction(SIGINT,&amp;new_act,&amp;old_act); 48 49 //这个操作是用于传递信号同时携带参数的情况，sa_flags需要被指定为sa_SIGINFO,并且调用的接口是sa_sigaction 50 sigemptyset(&amp;new_act.sa_mask); 51 new_act.sa_flags = SA_SIGINFO; 52 new_act.sa_sigaction = sigcb1; 53 sigaction(SIGQUIT,&amp;new_act,&amp;old_act); 54 while(1) 55 &#123; 56 sleep(1); 57 kill(getpid(),SIGINT); 58 //int sigqueue(pid_t pid, int sig, const union sigval value); //这个函数不仅可以发送信号，还可以 //顺便携带一 个信号 59 // pid:进程ID 60 // sig:信号编号 61 // sigval:参数 62 /* union sigval &#123; 63 int sival_int; 64 void *sival_ptr; 65 &#125;;*/ 66 union sigval val; 67 val.sival_int = 999; 68 sigqueue(getpid(),SIGQUIT,val);//传参函数 69 &#125; 70 return 0; 71 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F11%2F08%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[​ 在Linux系统下，一切皆文件，而对于一个文件必定需要权限去对其进行访问和操作，那么对于用户来说，可以通过哪些权限来访问文件呢？ ​ 首先，我们需要对Linux系统下文件访问权限有一定的了解：​ 文件权限值的表示方法： ​ 1.字符表示法： ​ 2.8进制数值表示法 那么如何设置且更改文件的访问权限呢？ ​ 使用chmod命令：格式为chmod[参数]权限 文件名 1.用户标识符+-=权限字符 ​ +：向权限范围增加权限代号所表示的权限 ​ -： 向权限范围取消权限代号所表示的权限 ​ =: 向权限范围赋予权限代号所表示的权限 ​ 用户符号： ​ u：拥有着 ​ g：拥有者同组用 ​ o：其他用户 ​ a：所有用户 chmod u+w /home/abc/txt chmod o-x /home/abc/txt chmod a=x /home/abc/txt 2.三位8进制数字 chmod 664 /home/abc/txt chmod 640 /home/abc/txt 下面进行具体的操作： 1.创建一个目录，并将其权限改为000 ​ 2.此时进入目录发现权限不够 3.给该目录所有者加上读权限，并尝试进入目录，发现权限不够 4.将该目录所有者的读权限取掉，加上写权限，进入目录，发现权限不够 5.将该目录所有者的写权限取掉，加上执行权限，进入目录，可以进入 由此可得： 1.读（r/4）：Read对文件而言，具有读取文件内容的权限 ​ 对于目录来说，具有浏览该目录信息的权限 2.写（w/2）：Write对文件而言，具有修改文件内容的权限 ​ 对于目录来货，具有删除移动目录内文件的权限 3.执行（x/1）：Execute对文件而言，具有执行文件的权限 ​ 对于文件而言，具有执行文件的权限 ​ 对于目录来说，具有进入**目录**的权限]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号之信号周期]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[信号是为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去处理事件，事件处理完毕之后进程回到原先运行位置继续运行信号更多的是通知事件发生，如红绿灯 在LInux下，用户输入命令在Shell下启动一个前台进程，而当按下ctrl+C时，产生一个硬中断，如果说CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断（终端驱动程序将 ctrl+c 解释成一个SIGINT信号，记在其进程的PCB中(也可以说是发送了一个SIGINT信号给该进程)),而当要从内核返回到进程的用户空间代码继续执行之前，首先处理PCB中记录的信号，此时会发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行 信号产生之后第一时间也不是直接处理而是先存储下来，处理信号 信号的生命周期：信号的产生 =》信号的注册 =》信号的注销 =》(信号的阻塞（只是不处理）) =》信号的处理 信号处理常见方式：1.忽略此信号2.执行该信号的默认处理动作3.提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号） 信号分了两类：1.非实时信号（不可靠信号）1~31 实时信号 (可靠信号) 34~64 信号的产生：1.通过硬件中断产生 （ctrl+c）2.程序异常产生 SIGFPE SIGSEGV3.软件条件(代码)产生软件条件产生：1.直接使用kill命令：kill并不是真的杀死进程，而是向一个进程发送一个信号（SIGTERM）kill -15 PID kill -15 PID2.kill接口int kill(pid_t pid, int sig); 向指定的进程发送指定的信号int raise(int sig); 发送一个信号给自身void abort(void); 使当前进程接受到信号而异常终止(像exit一样总会成功，所以没有返回值) unsigned int alarm(unsigned int seconds);在second秒之后，给进程发送一个STGALRM信号，在函数中可以多次调用如：设置一个定时器，取消上一个定时器，并且返回上一个定时器剩余时间 信号的注册：信号的注册（给一个进程发送信号），就是修改这个进程pcb中关于信号的pending位图，将相应的信号位置1 信号的阻塞：暂时不处理信号，并不是不接收信号，实际是暂时阻止信号的递达原理：要阻塞一个信号，那么就是修改pcb中关于信号的block位图，将相应的信号位置1，这个位图就像是 一个备注说明如果接收到这个信号暂时不处理注意：1.实际执行信号的处理动作称之为信号递达（动作）2.信号从产生到递达之间的状态，称之为信号未决（状态）3.进程可以选择阻塞某个信号4.被阻塞的信号产生时将保持在未决状态，知道进程解除对该信号的阻塞才执行递达动作5.阻塞和忽略时不同的，阻塞就不会递达，而忽略则是在递达之后可选的一种处理的动作 sigprocmask：int sigprocmask(int how, const sigset_t set, sigset_t oldset);调用sigprcmask（）接口，要么阻塞函数，要么对信号进行解除阻塞set：要阻塞或解除阻塞的集合oldset：保存原先阻塞集合中的信号如果oset非空，则读取进程当前的信号屏蔽字通过oset传出；若set非空，则根据how参数指示更改进程的信号屏蔽字；（解除阻塞或者设置阻塞）若oset和set均非空，则将原来的信号屏蔽字备份到oset中，然后根据how参数更改信号屏蔽字how参数：SIGBLOCKSIG_UNBLOCKSIG_SETMASKint sigemptyset(sigset_t set); int sigfillset(sigset_t set); int sigaddset(sigset_t set, int signum); int sigdelset(sigset_t set, int signum)； int sigismember(const sigset_t *set, int signum);123456789101112131415161718192021222324252627282930313233343536373839404142/* 这是一个演示信号阻塞的demo 2 */ 3 4 #include&lt;stdio.h&gt; 5 #include&lt;unistd.h&gt; 6 #include&lt;signal.h&gt; 7 8 int main() 9 &#123;10 //我要阻塞这个集合中的信号11 sigset_t new_block;12 //用于保存原来阻塞集合中的信号,防止后续要将阻塞集合还原回去13 sigset_t old_block;14 15 //int sigemptyset(sigset_t *set);16 //清空一个信号集合17 sigemptyset(&amp;new_block);18 //int sigfillset(sigset_t *set);19 //将所有的信号添加到set集合中20 // int sigaddset(sigset_t *set, int signum);21 //添加指定的单个信号到set集合中22 //int sigdelset(sigset_t *set, int signum);23 //从集合中移除一个信号24 //int sigismember(const sigset_t *set, int signum);25 //判断一个信号是否在一个集合中 26 sigfillset(&amp;new_block);27 //int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);28 //阻塞信号或解除阻塞29 //SIGBLOCK 阻塞集合中的信号30 //SIG_UNBLOCK 对集合中的信号解除阻塞31 //SIG_SETMASK 将集合中的信号设置到阻塞集合中32 //set：要阻塞或解除阻塞的集合33 //oldset：保存原先阻塞集合中的信号34 sigprocmask(SIG_BLOCK,&amp;new_block,&amp;old_block);35 //不按回车不往下走36 getchar();37 //解除阻塞38 sigprocmask(SIG_UNBLOCK,&amp;new_block,NULL);39 //将原先阻塞集合中的信号还原回去40 //sigprocmask(SIG_BLOCK,&amp;old_block,NULL);41 return 0;42 &#125; 有两个信号是不会被阻塞的：1.SIGKILL 2. SIGSTOPsigpending：获取一个未决信号int sigpending(sigset_t *set);（如果调用了sigpending接口，并且传入了一个集合地址，那么就会将pending集合中所有数据返回回来，相当于有哪些信号没有被处理则会返回回来） 信号注销：就是从pending集合中将即将要处理的信号置0（从pcb的pending集合中移除）非可靠信号注册就是将相应pending位图置1，然后添加一个sigqueue链表结构到链表中（一意味着这个信号来过），之后如果有相同信号到来，一看位图已经置1了，就不做操作了（意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了）可靠信号注册不管之前有没有注册都要置1 ，并且添加节点到链表中，所以不会丢掉信号 非可靠注销就是删除链表结点，相应位图置0可靠信号注销就是删除节点，判断是否有相同信号节点，如果没有位图置0，如果有就不置0，位图该位置还为1，下次会还处理这个信号struct sigqueue； 信号处理：1.忽略此信号——-直接将信号丢掉2.执行该信号的默认处理动作——-按照操作系统中对信号事件的既定处理方式3.自定义———-用户自己提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号）哪些接口可以供我们改变处理方式：1.signal #include &lt;signal.h&gt; typedef void (sighandler_t)(int); //函数指针的类型定义 sighandler_t signal(int signum, sighandler_t handler); signum:信号的ID，指定要改变的信号 sighandler_t handler：*信号的处理方式SIG_IGN（忽略信号） SIG_DFL（默认处理方式） or 自定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 2 * 这是一个演示signal接口修改信号处理方式的demo 3 * 信号的处理方式有三种： 4 * 忽略 5 * 默认 6 * 自定义 7 */ 8 9 #include&lt;stdio.h&gt; 10 #include&lt;unistd.h&gt; 11 #include&lt;signal.h&gt; 12 13 14 void sigcb(int signo) 15 &#123; 16 printf(&quot;receive signo:%d\n&quot;,signo); 17 /* if(signo == SIGINT ) //因为可能有很多信号来调用这个函数，所以需要做出判断 18 &#123; 19 &#125; 20 else 21 &#123; 22 &#125; 23 */ 24 return; 25 &#125; 26 27 28 int main() 29 &#123; 30 // sighandler_t signal(int signum, sighandler_t handler); 31 //signum:信号的编号 32 //handler：处理方式 33 // SIG_IGN 忽略 34 // SIG_DFL 默认 35 int i = 0; 36 //signal(SIGINT,SIG_IGN); //提前备注，当这个信号到来时忽略它 37 signal(SIGINT,sigcb); //自定义方式处理 38 while(1) 39 &#123; 40 printf(&quot;--------------\n&quot;); 41 kill(getpid(),SIGINT); 42 if(++i == 3) 43 &#123; 44 signal(SIGINT,SIG_DFL); 45 &#125; 46 &#125; 47 return 0; 48 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Dump浅解析]]></title>
    <url>%2F2018%2F11%2F08%2FCore-Dump%E6%B5%85%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Core Dump（核心转储）：当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，叫做Core Dump(保存当前程序运行的数据以及调用栈信息)，可以用于错误原因定位调试 为什么不用gdb呢？答：如果程序运行错误，可以直接通过core文件来gdb调试（有些错误可能是偶然发生的，可能在gdb调试时并不会显露出来，只有在core dump记录之后才能快速定位进行调试） CoreDump默认关闭：确保隐私安全/资源占用，1.记录的信息里面可能有隐秘性信息（如用户名和密码）2.Core Dump 文件很大且不会自动清理CoreDump打开：ulimit -c （int）当这个值为0 时则关闭（一个进程产生多大的core文件取决于进程的Resource Limit(这个信息保存在PCB中),使用ulimit命令改变这个限制）ulimit命令实际是改变Shell进程的Resourse Limit 1.首先将Core Dump打开 2.运行死循环程序 3.新建窗口，查看PID，并kill该程序 4.重新回到程序运行界面，发现已经Core Dumped，而ls产生了一个CoreDump文件 5.使用Core Dump文件查看错误（core-file ./test.992） 此时查看调用栈信息可以看到：__kernel_vsyscall ()，即为因死循环终止]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与delete的使用]]></title>
    <url>%2F2018%2F11%2F07%2Fnew%E4%B8%8Edelete%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[new运算符是给指针分配一片内存空间，与delete运算符一起使用，以达到直接进行动态内存分配和释放的目的new返回指定类型的一个指针，如果分配失败（如没有足够的内存空间），则返回012double *p；p = new double； 此时系统会根据double类型的空间大小来开辟一个内存空间，并将地址放在指针p中delete是释放new请求到的空间的 注意：1.delete必须来释放之前new分配的指针2.用new可以指定分配的内存大小1234int *p;p = new int(30); //为指针p开辟30个字节单元的内存单元...delete p; 3.new可以为数组分配内存，当释放时必须告诉delete数组中有多少元素1234int *p;p = new int[10];...delete [10] p ; 例：123456void Test()&#123;char* p;strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 此时只是给变量p分配了一个地址空间，并没有给p所指向的分配空间，所以程序出错应改为：1234567void Test()&#123;char *p;p = new char(10);strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 注意：对于用new运算符创建的对象，必须使用delete才能调用析构函数问题：看以下代码：12A *pa = new A[10];delete pa; 则类A的构造函数和析构函数分别执行了几次（）答：构造函数执行了10次，析构函数构造了1次]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（二）]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[运算符重载： operator + 合法的运算符 构成函数名（举例：重载&lt;运算符的函数名：operator&lt; ）。 重载运算符以后，不能改变运算符的 优先级/结合性/操作数个数。3.若成员变量为共有的，则可以重载为全局函数；若为私有的，重载为成员函数编译器对于==运算符的重载进行的操作： 5个C++不能重载的运算符是哪些？1..* 2. :: 3.sizeof 4.?: 5..注意：1.不能通过连接其他符号来创建新的操作符：如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，如不能将+重载为-4.作为类成员的重载函数，其形参看起来比操作数少1，因为操作符一个默认的形参this，限定为第一个形参 赋值运算符的重载：1.赋值运算符的重载是对一个已存在的对象进行拷贝赋值 。2.当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋 值运算符重载函数思考：为什么operator=赋值函数需要一个 Date&amp;的返回值， 使用void做返回值可以吗？//void Date&amp; operator=(const Date&amp; d) //引用效率较高,优先考虑引用 { _year = d._year; _month = d._month; _day = d._day; return this; }d1 = d2 = d3;需要注意：1.类型参数 2.返回值 3.检测是否自己给自己赋值 4.返回this 类的const成员函数：const修饰普通变量在C++中，const修饰的变量已经为一个常量，具有宏的属性，即在编译期间，编译器会将const所修饰的常量进行替换。const修饰类成员 const修饰类成员变量时，该成员变量必须在构造函数的初始化列表中初始化 const修饰类成员函数，实际修饰该成员函数隐含的this指针，该成员函数中不能对类的任何成员进行修改（ const Test* const）注意：在const成员函数中不能修改类的“成员变量”，因为const在此处修饰的是this指针指向空间中的内容，若需要对类的某个成员变量进行修改，该成员变量只需被mutable关键字修饰即可 思考：首先明确一点：非const函数实际是可读可写当前对象的函数，如SetData()，而const函数只能读取当前对象的内容,如GetData() const对象可以调用非const成员函数和const成员函数吗？答：不能调用普通非const类型成员函数，可以调用const类型成员函数(只读不可写) 非const对象可以调用非const成员函数和const成员函数吗？答： 可以，非const对象本身就具有可读属性，完全可以使用const函数 const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：不能调用非const函数，可以调用const类型成员函数 非const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：可以 类的取地址操作符重载 &amp; const修饰的取地址操作符重载 ：这两个默认成员函数一般不用重新定义 ，编译器默认会生成。当想让别人获取到你指定的内容才会需要你自己重载这两个操作符Test operator&amp;(){cout &lt;&lt; this &lt;&lt; endl;return this;} const Date operator&amp;() const{ return this ; }Test operator&amp;(); 和 const Test opertor&amp;();形成重载原因是：默认隐藏参数this指针类型不同，第一个是Test const，第二个是const Test const]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环的基础练习]]></title>
    <url>%2F2018%2F11%2F01%2Ffor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[无论是对于编程菜鸟或者是大牛来说，for循环是一个不可或缺的C语言语句，在这里其定义如何且按下不表，只是单纯的放几个for循环的适用场景来感受一下。for(表达式1；表达式2；表达式3)，请对应于下图来认真体会一下好的，多说无益，还是上上手来实际操作一下第一题：打印100~200 之间的素数在做这道题的时候，个人建议自己先想清楚什么是素数，如何判断一个数是不是素数，切忌没有想清楚就直接上手，建议在实操之前先写一下伪代码以下提供三种方式来处理这个问题：1.有多少个数就判断多少次，这种方法简单明了，一眼即懂，但是大大增加了代码的循环次数123456789101112131415void IsPrime1()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;i;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= i) printf(&quot;%d &quot;,i); &#125;&#125; 2.这一种较第一种减少了大概一般的循环次数，提高了代码效率123456789101112131415void IsPrime2()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;200/2;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= (i/2)) printf(&quot;%d &quot;,i); &#125;&#125; 3.此时的循环次数由n级数骤降到了sqrt(n)级上,但是针对这一种算法，一定要拎清楚输出的条件123456789101112131415void IsPrime3()&#123; int i = 100; for(i=101;i&lt;200;i+=2) &#123; int j = 2; for(j=2;j&lt;sqrt(1.0*i);j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= sqrt(1.0*i)) printf(&quot;%d &quot;,i); &#125;&#125; sqrt()是C语言函数库中封装好的函数，其在库中对参数分别为double,float,long double，有着三种不同的重载方式，此段代码中sqrt()中参数为1.0*i即是为了满足参数，方能调用该函数，切记要加头文件&lt;math.h&gt;二.输出乘法口诀表因为要输出成如图界面，一定要注意循环终止条件1234567891011121314void mul()&#123; int i = 0; for(i=1;i&lt;=9;i++) &#123; int j = 0; for(j=1;j&lt;=i;j++) &#123; int k = i*j; printf( &quot;%d*%d = %2d &quot;,j,i,k); &#125; printf(&quot;\n&quot;); &#125;&#125; 三. 判断1000年—2000年之间的闰年1234567891011void IsLeapYear()&#123; int year; for (year = 1000; year &lt;= 2000; year++) &#123; if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0 ) &#123; printf(&quot;%d &quot;, year); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C初阶基本练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（一）]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数：是一个特殊的成员函数（随着对象创建而自动被调用的），用于来初始化对象，在对象的生命周期中只调用一次特征：1.名字与类名相同2.无返回值（并不等同于void）3.可以重载（类可以有多个构造函数，其名字都必须相同但参数列表可以不同）4.类对象创建时自动执行！！！5.构造函数可以在类中定义，也可以在类外定义（在类中定义的成员函数，编译器可能会将其当成内联函数来处理）class Date(){public：/Date() //无参数，形成重载{_year = 1997;_month = 01;_day = 01;}/Date(int year,int month,int day) //无返回值类型，并不是void{_year = year;_month = month;_day = day;}private:int _year;int _month;int _day;} 注意：1.若一个类没有定义构造函数，则会自动生成一个不带参数的默认构造函数Date(){}; 此时创建Date d对象会报错，如何解决？答：将Date(int year,int month,int day)给上缺省值，即Date(int year = 1997,int month = 01,int day = 01)，使得对象若没有参数则直接使用缺省值（无参的和带有全缺省的构造函数只能存在一个，即Date（）{}；和Date(int year = 1997,int month = 01,int day = 01只能存在一个) 析构函数：与构造函数功能相反（~），在对象被销毁时编译器自动调用，析构函数体做一些对象删除前的相关资源清理工作（不是删除对象）特征： 析构函数名是在类名前加上字符 ~。 无参数无返回值。 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数注意：对于用new运算符动态创建的对象，只有用delete释放对象时才调用析构函数 拷贝构造函数：用已经存在的对象创建新的对象只有单个形参，该形参是对本类类型对象的引用（因为是拷贝，不需要更改原对象的任何参数，为了安全起见一般常用const修饰）特征： 拷贝构造函数其实是一个构造函数的重载。 拷贝构造函数的参数只有一个且必须使用引用传参（使用传值方式会引发无穷递归调用） 若未显示定义，系统会默认生成默认的拷贝构造函数。 默认的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化（默认方式下是原封不动完全拷贝，包括地址）Date(const Date&amp; d){_year = d._year;_month = d._month;_day = d._day;}哪些类的拷贝构造函数用户一定要提供？对象中有资源（动态的顺序表，若拷贝s1到s2时，因为要进行free，先free的是s2，在free之后s2指向空间已经被销毁而s1并不知道，所以在s1 free的时候出错）]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
