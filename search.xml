<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Core Dump浅解析]]></title>
    <url>%2F2018%2F11%2F08%2FCore-Dump%E6%B5%85%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Core Dump（核心转储）：当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，叫做Core Dump(保存当前程序运行的数据以及调用栈信息)，可以用于错误原因定位调试 为什么不用gdb呢？答：如果程序运行错误，可以直接通过core文件来gdb调试（有些错误可能是偶然发生的，可能在gdb调试时并不会显露出来，只有在core dump记录之后才能快速定位进行调试） CoreDump默认关闭：确保隐私安全/资源占用，1.记录的信息里面可能有隐秘性信息（如用户名和密码）2.Core Dump 文件很大且不会自动清理CoreDump打开：ulimit -c （int）当这个值为0 时则关闭（一个进程产生多大的core文件取决于进程的Resource Limit(这个信息保存在PCB中),使用ulimit命令改变这个限制）ulimit命令实际是改变Shell进程的Resourse Limit 1.首先将Core Dump打开 2.运行死循环程序 3.新建窗口，查看PID，并kill该程序 4.重新回到程序运行界面，发现已经Core Dumped，而ls产生了一个CoreDump文件 5.使用Core Dump文件查看错误（core-file ./test.992） 此时查看调用栈信息可以看到：__kernel_vsyscall ()，即为因死循环终止]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与delete的使用]]></title>
    <url>%2F2018%2F11%2F07%2Fnew%E4%B8%8Edelete%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[new运算符是给指针分配一片内存空间，与delete运算符一起使用，以达到直接进行动态内存分配和释放的目的new返回指定类型的一个指针，如果分配失败（如没有足够的内存空间），则返回012double *p；p = new double； 此时系统会根据double类型的空间大小来开辟一个内存空间，并将地址放在指针p中delete是释放new请求到的空间的 注意：1.delete必须来释放之前new分配的指针2.用new可以指定分配的内存大小1234int *p;p = new int(30); //为指针p开辟30个字节单元的内存单元...delete p; 3.new可以为数组分配内存，当释放时必须告诉delete数组中有多少元素1234int *p;p = new int[10];...delete [10] p ; 例：123456void Test()&#123;char* p;strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 此时只是给变量p分配了一个地址空间，并没有给p所指向的分配空间，所以程序出错应改为：1234567void Test()&#123;char *p;p = new char(10);strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 注意：对于用new运算符创建的对象，必须使用delete才能调用析构函数问题：看以下代码：12A *pa = new A[10];delete pa; 则类A的构造函数和析构函数分别执行了几次（）答：构造函数执行了10次，析构函数构造了1次]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（二）]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[运算符重载： operator + 合法的运算符 构成函数名（举例：重载&lt;运算符的函数名：operator&lt; ）。 重载运算符以后，不能改变运算符的 优先级/结合性/操作数个数。3.若成员变量为共有的，则可以重载为全局函数；若为私有的，重载为成员函数编译器对于==运算符的重载进行的操作： 5个C++不能重载的运算符是哪些？1..* 2. :: 3.sizeof 4.?: 5..注意：1.不能通过连接其他符号来创建新的操作符：如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，如不能将+重载为-4.作为类成员的重载函数，其形参看起来比操作数少1，因为操作符一个默认的形参this，限定为第一个形参 赋值运算符的重载：1.赋值运算符的重载是对一个已存在的对象进行拷贝赋值 。2.当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋 值运算符重载函数思考：为什么operator=赋值函数需要一个 Date&amp;的返回值， 使用void做返回值可以吗？//void Date&amp; operator=(const Date&amp; d) //引用效率较高,优先考虑引用 { _year = d._year; _month = d._month; _day = d._day; return this; }d1 = d2 = d3;需要注意：1.类型参数 2.返回值 3.检测是否自己给自己赋值 4.返回this 类的const成员函数：const修饰普通变量在C++中，const修饰的变量已经为一个常量，具有宏的属性，即在编译期间，编译器会将const所修饰的常量进行替换。const修饰类成员 const修饰类成员变量时，该成员变量必须在构造函数的初始化列表中初始化 const修饰类成员函数，实际修饰该成员函数隐含的this指针，该成员函数中不能对类的任何成员进行修改（ const Test* const）注意：在const成员函数中不能修改类的“成员变量”，因为const在此处修饰的是this指针指向空间中的内容，若需要对类的某个成员变量进行修改，该成员变量只需被mutable关键字修饰即可 思考：首先明确一点：非const函数实际是可读可写当前对象的函数，如SetData()，而const函数只能读取当前对象的内容,如GetData() const对象可以调用非const成员函数和const成员函数吗？答：不能调用普通非const类型成员函数，可以调用const类型成员函数(只读不可写) 非const对象可以调用非const成员函数和const成员函数吗？答： 可以，非const对象本身就具有可读属性，完全可以使用const函数 const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：不能调用非const函数，可以调用const类型成员函数 非const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：可以 类的取地址操作符重载 &amp; const修饰的取地址操作符重载 ：这两个默认成员函数一般不用重新定义 ，编译器默认会生成。当想让别人获取到你指定的内容才会需要你自己重载这两个操作符Test operator&amp;(){cout &lt;&lt; this &lt;&lt; endl;return this;} const Date operator&amp;() const{ return this ; }Test operator&amp;(); 和 const Test opertor&amp;();形成重载原因是：默认隐藏参数this指针类型不同，第一个是Test const，第二个是const Test const]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环的基础练习]]></title>
    <url>%2F2018%2F11%2F01%2Ffor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[无论是对于编程菜鸟或者是大牛来说，for循环是一个不可或缺的C语言语句，在这里其定义如何且按下不表，只是单纯的放几个for循环的适用场景来感受一下。for(表达式1；表达式2；表达式3)，请对应于下图来认真体会一下好的，多说无益，还是上上手来实际操作一下第一题：打印100~200 之间的素数在做这道题的时候，个人建议自己先想清楚什么是素数，如何判断一个数是不是素数，切忌没有想清楚就直接上手，建议在实操之前先写一下伪代码以下提供三种方式来处理这个问题：1.有多少个数就判断多少次，这种方法简单明了，一眼即懂，但是大大增加了代码的循环次数123456789101112131415void IsPrime1()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;i;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= i) printf(&quot;%d &quot;,i); &#125;&#125; 2.这一种较第一种减少了大概一般的循环次数，提高了代码效率123456789101112131415void IsPrime2()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;200/2;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= (i/2)) printf(&quot;%d &quot;,i); &#125;&#125; 3.此时的循环次数由n级数骤降到了sqrt(n)级上,但是针对这一种算法，一定要拎清楚输出的条件123456789101112131415void IsPrime3()&#123; int i = 100; for(i=101;i&lt;200;i+=2) &#123; int j = 2; for(j=2;j&lt;sqrt(1.0*i);j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= sqrt(1.0*i)) printf(&quot;%d &quot;,i); &#125;&#125; sqrt()是C语言函数库中封装好的函数，其在库中对参数分别为double,float,long double，有着三种不同的重载方式，此段代码中sqrt()中参数为1.0*i即是为了满足参数，方能调用该函数，切记要加头文件&lt;math.h&gt;二.输出乘法口诀表因为要输出成如图界面，一定要注意循环终止条件1234567891011121314void mul()&#123; int i = 0; for(i=1;i&lt;=9;i++) &#123; int j = 0; for(j=1;j&lt;=i;j++) &#123; int k = i*j; printf( &quot;%d*%d = %2d &quot;,j,i,k); &#125; printf(&quot;\n&quot;); &#125;&#125; 三. 判断1000年—2000年之间的闰年1234567891011void IsLeapYear()&#123; int year; for (year = 1000; year &lt;= 2000; year++) &#123; if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0 ) &#123; printf(&quot;%d &quot;, year); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C初阶基本练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（一）]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数：是一个特殊的成员函数（随着对象创建而自动被调用的），用于来初始化对象，在对象的生命周期中只调用一次特征：1.名字与类名相同2.无返回值（并不等同于void）3.可以重载（类可以有多个构造函数，其名字都必须相同但参数列表可以不同）4.类对象创建时自动执行！！！5.构造函数可以在类中定义，也可以在类外定义（在类中定义的成员函数，编译器可能会将其当成内联函数来处理）class Date(){public：/Date() //无参数，形成重载{_year = 1997;_month = 01;_day = 01;}/Date(int year,int month,int day) //无返回值类型，并不是void{_year = year;_month = month;_day = day;}private:int _year;int _month;int _day;} 注意：1.若一个类没有定义构造函数，则会自动生成一个不带参数的默认构造函数Date(){}; 此时创建Date d对象会报错，如何解决？答：将Date(int year,int month,int day)给上缺省值，即Date(int year = 1997,int month = 01,int day = 01)，使得对象若没有参数则直接使用缺省值（无参的和带有全缺省的构造函数只能存在一个，即Date（）{}；和Date(int year = 1997,int month = 01,int day = 01只能存在一个) 析构函数：与构造函数功能相反（~），在对象被销毁时编译器自动调用，析构函数体做一些对象删除前的相关资源清理工作（不是删除对象）特征： 析构函数名是在类名前加上字符 ~。 无参数无返回值。 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数注意：对于用new运算符动态创建的对象，只有用delete释放对象时才调用析构函数 拷贝构造函数：用已经存在的对象创建新的对象只有单个形参，该形参是对本类类型对象的引用（因为是拷贝，不需要更改原对象的任何参数，为了安全起见一般常用const修饰）特征： 拷贝构造函数其实是一个构造函数的重载。 拷贝构造函数的参数只有一个且必须使用引用传参（使用传值方式会引发无穷递归调用） 若未显示定义，系统会默认生成默认的拷贝构造函数。 默认的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化（默认方式下是原封不动完全拷贝，包括地址）Date(const Date&amp; d){_year = d._year;_month = d._month;_day = d._day;}哪些类的拷贝构造函数用户一定要提供？对象中有资源（动态的顺序表，若拷贝s1到s2时，因为要进行free，先free的是s2，在free之后s2指向空间已经被销毁而s1并不知道，所以在s1 free的时候出错）]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
