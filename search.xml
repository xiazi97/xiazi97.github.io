<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进程信号之自定义处理]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[信号的捕捉流程：主要是针对信号的自定义处理方式 信号并不是立即处理的，而是选择一个合适的时机去处理，合适的时机就是当前程序从内核态切换到用户态的时候 注意：程序如何从用户态切换到内核态? 答：1.程序异常的时候 2.发起系统调用的时候 3.中断的时候 信号的捕捉是当我们发起系统调用/程序异常/中断当前程序从内核态运行切换到用户态，去处理这些事情，处理完毕之后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕之后再次返回内核态，判断没有信号要处理了就调用sys_sigreturn返回用户态（我们程序之前运行的位置）（就像我们课堂上布置的作业不会立即写） 注意：在使用这个接口时可能会因为该函数是库函数，而在Linux下的系统版本下会有细微差异 多是使用此函数所调用的系统调用接口sigaction 123456789int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);signum:指定给哪个信号去自定义处理方式act：新的处理方式oldact：保存新自定义之前的原本的操作 12345678910111213141516171819struct sigaction &#123;//都是信号的回调函数（取决于flags），任意指定其一 void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *);//传递信号并同时携带参数//当处理时不希望被别的信号所影响，所以使用sa_mask来指定需要暂时阻塞的信号 sigset_t sa_mask;//当flags被指定为SA_SIGINFO这个参数时回调的是sa_sigaction，否则都是调用handler int sa_flags; void (*sa_restorer)(void); &#125;; 下边是一个sigaction的使用demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 1 /* 2 * 因为signal这个接口有linux版本的差异性，因此可以使用sigaction这个接口来替代signal函数， 3 * 它的功能也是自定义信号的处理方式，并且signal函数内部也是通过sigaction来实现的 4 * 5 * 6 */ 7 8 /* struct sigaction &#123; 9 void (*sa_handler)(int);//处理函数 10 void (*sa_sigaction)(int, siginfo_t *, void *);//处理函数（当flags被指定为SA_SIGINFO这个参数时回调） 11 sigset_t sa_mask;//在处理信号时通过这个mask暂时阻塞一些信号，处理完之后还原 12 int sa_flags;//决定使用哪个处理接口 13 void (*sa_restorer)(void); 14 &#125;;*/ 15 16 17 #include&lt;stdio.h&gt; 18 #include&lt;unistd.h&gt; 19 #include&lt;signal.h&gt; 20 21 void sigcb(int signo) 22 &#123; 23 printf(&quot;rec signal:%d\n&quot;,signo); 24 &#125; 25 26 void sigcb1(int signo,siginfo_t* info,void* context)//context为预留的，不是传的参数，暂时不管它 27 &#123; 28 printf(&quot;rec signo:%d---param:%d\n&quot;,signo,info-&gt;si_int); 29 &#125; 30 31 32 int main() 33 &#123;34 struct sigaction new_act; 35 struct sigaction old_act; 36 //重新定义处理方式的信号为SIGINT SINQUIT 37 //int sigaction(int signum, const struct sigaction *act, 38 // struct sigaction *oldact); 39 //signum:信号编号 40 //act:新的处理方式 41 //oldact:保存原有的处理方式 42 43 //这个操作时一般性的更改一个信号的处理方式，sa_flags =0代表使用的回调接口为sa_handler 44 sigemptyset(&amp;new_act.sa_mask); 45 new_act.sa_flags = 0; 46 new_act.sa_handler = sigcb; 47 sigaction(SIGINT,&amp;new_act,&amp;old_act); 48 49 //这个操作是用于传递信号同时携带参数的情况，sa_flags需要被指定为sa_SIGINFO,并且调用的接口是sa_sigaction 50 sigemptyset(&amp;new_act.sa_mask); 51 new_act.sa_flags = SA_SIGINFO; 52 new_act.sa_sigaction = sigcb1; 53 sigaction(SIGQUIT,&amp;new_act,&amp;old_act); 54 while(1) 55 &#123; 56 sleep(1); 57 kill(getpid(),SIGINT); 58 //int sigqueue(pid_t pid, int sig, const union sigval value); //这个函数不仅可以发送信号，还可以 //顺便携带一 个信号 59 // pid:进程ID 60 // sig:信号编号 61 // sigval:参数 62 /* union sigval &#123; 63 int sival_int; 64 void *sival_ptr; 65 &#125;;*/ 66 union sigval val; 67 val.sival_int = 999; 68 sigqueue(getpid(),SIGQUIT,val);//传参函数 69 &#125; 70 return 0; 71 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F11%2F08%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[​ 在Linux系统下，一切皆文件，而对于一个文件必定需要权限去对其进行访问和操作，那么对于用户来说，可以通过哪些权限来访问文件呢？ ​ 首先，我们需要对Linux系统下文件访问权限有一定的了解：​ 文件权限值的表示方法： ​ 1.字符表示法： ​ 2.8进制数值表示法 那么如何设置且更改文件的访问权限呢？ ​ 使用chmod命令：格式为chmod[参数]权限 文件名 1.用户标识符+-=权限字符 ​ +：向权限范围增加权限代号所表示的权限 ​ -： 向权限范围取消权限代号所表示的权限 ​ =: 向权限范围赋予权限代号所表示的权限 ​ 用户符号： ​ u：拥有着 ​ g：拥有者同组用 ​ o：其他用户 ​ a：所有用户 chmod u+w /home/abc/txt chmod o-x /home/abc/txt chmod a=x /home/abc/txt 2.三位8进制数字 chmod 664 /home/abc/txt chmod 640 /home/abc/txt 下面进行具体的操作： 1.创建一个目录，并将其权限改为000 ​ 2.此时进入目录发现权限不够 3.给该目录所有者加上读权限，并尝试进入目录，发现权限不够 4.将该目录所有者的读权限取掉，加上写权限，进入目录，发现权限不够 5.将该目录所有者的写权限取掉，加上执行权限，进入目录，可以进入 由此可得： 1.读（r/4）：Read对文件而言，具有读取文件内容的权限 ​ 对于目录来说，具有浏览该目录信息的权限 2.写（w/2）：Write对文件而言，具有修改文件内容的权限 ​ 对于目录来货，具有删除移动目录内文件的权限 3.执行（x/1）：Execute对文件而言，具有执行文件的权限 ​ 对于文件而言，具有执行文件的权限 ​ 对于目录来说，具有进入**目录**的权限]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号之信号周期]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[信号是为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去处理事件，事件处理完毕之后进程回到原先运行位置继续运行信号更多的是通知事件发生，如红绿灯 在LInux下，用户输入命令在Shell下启动一个前台进程，而当按下ctrl+C时，产生一个硬中断，如果说CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断（终端驱动程序将 ctrl+c 解释成一个SIGINT信号，记在其进程的PCB中(也可以说是发送了一个SIGINT信号给该进程)),而当要从内核返回到进程的用户空间代码继续执行之前，首先处理PCB中记录的信号，此时会发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行 信号产生之后第一时间也不是直接处理而是先存储下来，处理信号 信号的生命周期：信号的产生 =》信号的注册 =》信号的注销 =》(信号的阻塞（只是不处理）) =》信号的处理 信号处理常见方式：1.忽略此信号2.执行该信号的默认处理动作3.提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号） 信号分了两类：1.非实时信号（不可靠信号）1~31 实时信号 (可靠信号) 34~64 信号的产生：1.通过硬件中断产生 （ctrl+c）2.程序异常产生 SIGFPE SIGSEGV3.软件条件(代码)产生软件条件产生：1.直接使用kill命令：kill并不是真的杀死进程，而是向一个进程发送一个信号（SIGTERM）kill -15 PID kill -15 PID2.kill接口int kill(pid_t pid, int sig); 向指定的进程发送指定的信号int raise(int sig); 发送一个信号给自身void abort(void); 使当前进程接受到信号而异常终止(像exit一样总会成功，所以没有返回值) unsigned int alarm(unsigned int seconds);在second秒之后，给进程发送一个STGALRM信号，在函数中可以多次调用如：设置一个定时器，取消上一个定时器，并且返回上一个定时器剩余时间 信号的注册：信号的注册（给一个进程发送信号），就是修改这个进程pcb中关于信号的pending位图，将相应的信号位置1 信号的阻塞：暂时不处理信号，并不是不接收信号，实际是暂时阻止信号的递达原理：要阻塞一个信号，那么就是修改pcb中关于信号的block位图，将相应的信号位置1，这个位图就像是 一个备注说明如果接收到这个信号暂时不处理注意：1.实际执行信号的处理动作称之为信号递达（动作）2.信号从产生到递达之间的状态，称之为信号未决（状态）3.进程可以选择阻塞某个信号4.被阻塞的信号产生时将保持在未决状态，知道进程解除对该信号的阻塞才执行递达动作5.阻塞和忽略时不同的，阻塞就不会递达，而忽略则是在递达之后可选的一种处理的动作 sigprocmask：int sigprocmask(int how, const sigset_t set, sigset_t oldset);调用sigprcmask（）接口，要么阻塞函数，要么对信号进行解除阻塞set：要阻塞或解除阻塞的集合oldset：保存原先阻塞集合中的信号如果oset非空，则读取进程当前的信号屏蔽字通过oset传出；若set非空，则根据how参数指示更改进程的信号屏蔽字；（解除阻塞或者设置阻塞）若oset和set均非空，则将原来的信号屏蔽字备份到oset中，然后根据how参数更改信号屏蔽字how参数：SIGBLOCKSIG_UNBLOCKSIG_SETMASKint sigemptyset(sigset_t set); int sigfillset(sigset_t set); int sigaddset(sigset_t set, int signum); int sigdelset(sigset_t set, int signum)； int sigismember(const sigset_t *set, int signum);123456789101112131415161718192021222324252627282930313233343536373839404142/* 这是一个演示信号阻塞的demo 2 */ 3 4 #include&lt;stdio.h&gt; 5 #include&lt;unistd.h&gt; 6 #include&lt;signal.h&gt; 7 8 int main() 9 &#123;10 //我要阻塞这个集合中的信号11 sigset_t new_block;12 //用于保存原来阻塞集合中的信号,防止后续要将阻塞集合还原回去13 sigset_t old_block;14 15 //int sigemptyset(sigset_t *set);16 //清空一个信号集合17 sigemptyset(&amp;new_block);18 //int sigfillset(sigset_t *set);19 //将所有的信号添加到set集合中20 // int sigaddset(sigset_t *set, int signum);21 //添加指定的单个信号到set集合中22 //int sigdelset(sigset_t *set, int signum);23 //从集合中移除一个信号24 //int sigismember(const sigset_t *set, int signum);25 //判断一个信号是否在一个集合中 26 sigfillset(&amp;new_block);27 //int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);28 //阻塞信号或解除阻塞29 //SIGBLOCK 阻塞集合中的信号30 //SIG_UNBLOCK 对集合中的信号解除阻塞31 //SIG_SETMASK 将集合中的信号设置到阻塞集合中32 //set：要阻塞或解除阻塞的集合33 //oldset：保存原先阻塞集合中的信号34 sigprocmask(SIG_BLOCK,&amp;new_block,&amp;old_block);35 //不按回车不往下走36 getchar();37 //解除阻塞38 sigprocmask(SIG_UNBLOCK,&amp;new_block,NULL);39 //将原先阻塞集合中的信号还原回去40 //sigprocmask(SIG_BLOCK,&amp;old_block,NULL);41 return 0;42 &#125; 有两个信号是不会被阻塞的：1.SIGKILL 2. SIGSTOPsigpending：获取一个未决信号int sigpending(sigset_t *set);（如果调用了sigpending接口，并且传入了一个集合地址，那么就会将pending集合中所有数据返回回来，相当于有哪些信号没有被处理则会返回回来） 信号注销：就是从pending集合中将即将要处理的信号置0（从pcb的pending集合中移除）非可靠信号注册就是将相应pending位图置1，然后添加一个sigqueue链表结构到链表中（一意味着这个信号来过），之后如果有相同信号到来，一看位图已经置1了，就不做操作了（意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了）可靠信号注册不管之前有没有注册都要置1 ，并且添加节点到链表中，所以不会丢掉信号 非可靠注销就是删除链表结点，相应位图置0可靠信号注销就是删除节点，判断是否有相同信号节点，如果没有位图置0，如果有就不置0，位图该位置还为1，下次会还处理这个信号struct sigqueue； 信号处理：1.忽略此信号——-直接将信号丢掉2.执行该信号的默认处理动作——-按照操作系统中对信号事件的既定处理方式3.自定义———-用户自己提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号）哪些接口可以供我们改变处理方式：1.signal #include &lt;signal.h&gt; typedef void (sighandler_t)(int); //函数指针的类型定义 sighandler_t signal(int signum, sighandler_t handler); signum:信号的ID，指定要改变的信号 sighandler_t handler：*信号的处理方式SIG_IGN（忽略信号） SIG_DFL（默认处理方式） or 自定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 2 * 这是一个演示signal接口修改信号处理方式的demo 3 * 信号的处理方式有三种： 4 * 忽略 5 * 默认 6 * 自定义 7 */ 8 9 #include&lt;stdio.h&gt; 10 #include&lt;unistd.h&gt; 11 #include&lt;signal.h&gt; 12 13 14 void sigcb(int signo) 15 &#123; 16 printf(&quot;receive signo:%d\n&quot;,signo); 17 /* if(signo == SIGINT ) //因为可能有很多信号来调用这个函数，所以需要做出判断 18 &#123; 19 &#125; 20 else 21 &#123; 22 &#125; 23 */ 24 return; 25 &#125; 26 27 28 int main() 29 &#123; 30 // sighandler_t signal(int signum, sighandler_t handler); 31 //signum:信号的编号 32 //handler：处理方式 33 // SIG_IGN 忽略 34 // SIG_DFL 默认 35 int i = 0; 36 //signal(SIGINT,SIG_IGN); //提前备注，当这个信号到来时忽略它 37 signal(SIGINT,sigcb); //自定义方式处理 38 while(1) 39 &#123; 40 printf(&quot;--------------\n&quot;); 41 kill(getpid(),SIGINT); 42 if(++i == 3) 43 &#123; 44 signal(SIGINT,SIG_DFL); 45 &#125; 46 &#125; 47 return 0; 48 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Dump浅解析]]></title>
    <url>%2F2018%2F11%2F08%2FCore-Dump%E6%B5%85%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Core Dump（核心转储）：当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，叫做Core Dump(保存当前程序运行的数据以及调用栈信息)，可以用于错误原因定位调试 为什么不用gdb呢？答：如果程序运行错误，可以直接通过core文件来gdb调试（有些错误可能是偶然发生的，可能在gdb调试时并不会显露出来，只有在core dump记录之后才能快速定位进行调试） CoreDump默认关闭：确保隐私安全/资源占用，1.记录的信息里面可能有隐秘性信息（如用户名和密码）2.Core Dump 文件很大且不会自动清理CoreDump打开：ulimit -c （int）当这个值为0 时则关闭（一个进程产生多大的core文件取决于进程的Resource Limit(这个信息保存在PCB中),使用ulimit命令改变这个限制）ulimit命令实际是改变Shell进程的Resourse Limit 1.首先将Core Dump打开 2.运行死循环程序 3.新建窗口，查看PID，并kill该程序 4.重新回到程序运行界面，发现已经Core Dumped，而ls产生了一个CoreDump文件 5.使用Core Dump文件查看错误（core-file ./test.992） 此时查看调用栈信息可以看到：__kernel_vsyscall ()，即为因死循环终止]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与delete的使用]]></title>
    <url>%2F2018%2F11%2F07%2Fnew%E4%B8%8Edelete%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[new运算符是给指针分配一片内存空间，与delete运算符一起使用，以达到直接进行动态内存分配和释放的目的new返回指定类型的一个指针，如果分配失败（如没有足够的内存空间），则返回012double *p；p = new double； 此时系统会根据double类型的空间大小来开辟一个内存空间，并将地址放在指针p中delete是释放new请求到的空间的 注意：1.delete必须来释放之前new分配的指针2.用new可以指定分配的内存大小1234int *p;p = new int(30); //为指针p开辟30个字节单元的内存单元...delete p; 3.new可以为数组分配内存，当释放时必须告诉delete数组中有多少元素1234int *p;p = new int[10];...delete [10] p ; 例：123456void Test()&#123;char* p;strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 此时只是给变量p分配了一个地址空间，并没有给p所指向的分配空间，所以程序出错应改为：1234567void Test()&#123;char *p;p = new char(10);strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 注意：对于用new运算符创建的对象，必须使用delete才能调用析构函数问题：看以下代码：12A *pa = new A[10];delete pa; 则类A的构造函数和析构函数分别执行了几次（）答：构造函数执行了10次，析构函数构造了1次]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（二）]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[运算符重载： operator + 合法的运算符 构成函数名（举例：重载&lt;运算符的函数名：operator&lt; ）。 重载运算符以后，不能改变运算符的 优先级/结合性/操作数个数。3.若成员变量为共有的，则可以重载为全局函数；若为私有的，重载为成员函数编译器对于==运算符的重载进行的操作： 5个C++不能重载的运算符是哪些？1..* 2. :: 3.sizeof 4.?: 5..注意：1.不能通过连接其他符号来创建新的操作符：如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，如不能将+重载为-4.作为类成员的重载函数，其形参看起来比操作数少1，因为操作符一个默认的形参this，限定为第一个形参 赋值运算符的重载：1.赋值运算符的重载是对一个已存在的对象进行拷贝赋值 。2.当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋 值运算符重载函数思考：为什么operator=赋值函数需要一个 Date&amp;的返回值， 使用void做返回值可以吗？//void Date&amp; operator=(const Date&amp; d) //引用效率较高,优先考虑引用 { _year = d._year; _month = d._month; _day = d._day; return this; }d1 = d2 = d3;需要注意：1.类型参数 2.返回值 3.检测是否自己给自己赋值 4.返回this 类的const成员函数：const修饰普通变量在C++中，const修饰的变量已经为一个常量，具有宏的属性，即在编译期间，编译器会将const所修饰的常量进行替换。const修饰类成员 const修饰类成员变量时，该成员变量必须在构造函数的初始化列表中初始化 const修饰类成员函数，实际修饰该成员函数隐含的this指针，该成员函数中不能对类的任何成员进行修改（ const Test* const）注意：在const成员函数中不能修改类的“成员变量”，因为const在此处修饰的是this指针指向空间中的内容，若需要对类的某个成员变量进行修改，该成员变量只需被mutable关键字修饰即可 思考：首先明确一点：非const函数实际是可读可写当前对象的函数，如SetData()，而const函数只能读取当前对象的内容,如GetData() const对象可以调用非const成员函数和const成员函数吗？答：不能调用普通非const类型成员函数，可以调用const类型成员函数(只读不可写) 非const对象可以调用非const成员函数和const成员函数吗？答： 可以，非const对象本身就具有可读属性，完全可以使用const函数 const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：不能调用非const函数，可以调用const类型成员函数 非const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：可以 类的取地址操作符重载 &amp; const修饰的取地址操作符重载 ：这两个默认成员函数一般不用重新定义 ，编译器默认会生成。当想让别人获取到你指定的内容才会需要你自己重载这两个操作符Test operator&amp;(){cout &lt;&lt; this &lt;&lt; endl;return this;} const Date operator&amp;() const{ return this ; }Test operator&amp;(); 和 const Test opertor&amp;();形成重载原因是：默认隐藏参数this指针类型不同，第一个是Test const，第二个是const Test const]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环的基础练习]]></title>
    <url>%2F2018%2F11%2F01%2Ffor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[无论是对于编程菜鸟或者是大牛来说，for循环是一个不可或缺的C语言语句，在这里其定义如何且按下不表，只是单纯的放几个for循环的适用场景来感受一下。for(表达式1；表达式2；表达式3)，请对应于下图来认真体会一下好的，多说无益，还是上上手来实际操作一下第一题：打印100~200 之间的素数在做这道题的时候，个人建议自己先想清楚什么是素数，如何判断一个数是不是素数，切忌没有想清楚就直接上手，建议在实操之前先写一下伪代码以下提供三种方式来处理这个问题：1.有多少个数就判断多少次，这种方法简单明了，一眼即懂，但是大大增加了代码的循环次数123456789101112131415void IsPrime1()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;i;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= i) printf(&quot;%d &quot;,i); &#125;&#125; 2.这一种较第一种减少了大概一般的循环次数，提高了代码效率123456789101112131415void IsPrime2()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;200/2;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= (i/2)) printf(&quot;%d &quot;,i); &#125;&#125; 3.此时的循环次数由n级数骤降到了sqrt(n)级上,但是针对这一种算法，一定要拎清楚输出的条件123456789101112131415void IsPrime3()&#123; int i = 100; for(i=101;i&lt;200;i+=2) &#123; int j = 2; for(j=2;j&lt;sqrt(1.0*i);j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= sqrt(1.0*i)) printf(&quot;%d &quot;,i); &#125;&#125; sqrt()是C语言函数库中封装好的函数，其在库中对参数分别为double,float,long double，有着三种不同的重载方式，此段代码中sqrt()中参数为1.0*i即是为了满足参数，方能调用该函数，切记要加头文件&lt;math.h&gt;二.输出乘法口诀表因为要输出成如图界面，一定要注意循环终止条件1234567891011121314void mul()&#123; int i = 0; for(i=1;i&lt;=9;i++) &#123; int j = 0; for(j=1;j&lt;=i;j++) &#123; int k = i*j; printf( &quot;%d*%d = %2d &quot;,j,i,k); &#125; printf(&quot;\n&quot;); &#125;&#125; 三. 判断1000年—2000年之间的闰年1234567891011void IsLeapYear()&#123; int year; for (year = 1000; year &lt;= 2000; year++) &#123; if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0 ) &#123; printf(&quot;%d &quot;, year); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C初阶基本练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（一）]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数：是一个特殊的成员函数（随着对象创建而自动被调用的），用于来初始化对象，在对象的生命周期中只调用一次特征：1.名字与类名相同2.无返回值（并不等同于void）3.可以重载（类可以有多个构造函数，其名字都必须相同但参数列表可以不同）4.类对象创建时自动执行！！！5.构造函数可以在类中定义，也可以在类外定义（在类中定义的成员函数，编译器可能会将其当成内联函数来处理）class Date(){public：/Date() //无参数，形成重载{_year = 1997;_month = 01;_day = 01;}/Date(int year,int month,int day) //无返回值类型，并不是void{_year = year;_month = month;_day = day;}private:int _year;int _month;int _day;} 注意：1.若一个类没有定义构造函数，则会自动生成一个不带参数的默认构造函数Date(){}; 此时创建Date d对象会报错，如何解决？答：将Date(int year,int month,int day)给上缺省值，即Date(int year = 1997,int month = 01,int day = 01)，使得对象若没有参数则直接使用缺省值（无参的和带有全缺省的构造函数只能存在一个，即Date（）{}；和Date(int year = 1997,int month = 01,int day = 01只能存在一个) 析构函数：与构造函数功能相反（~），在对象被销毁时编译器自动调用，析构函数体做一些对象删除前的相关资源清理工作（不是删除对象）特征： 析构函数名是在类名前加上字符 ~。 无参数无返回值。 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数注意：对于用new运算符动态创建的对象，只有用delete释放对象时才调用析构函数 拷贝构造函数：用已经存在的对象创建新的对象只有单个形参，该形参是对本类类型对象的引用（因为是拷贝，不需要更改原对象的任何参数，为了安全起见一般常用const修饰）特征： 拷贝构造函数其实是一个构造函数的重载。 拷贝构造函数的参数只有一个且必须使用引用传参（使用传值方式会引发无穷递归调用） 若未显示定义，系统会默认生成默认的拷贝构造函数。 默认的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化（默认方式下是原封不动完全拷贝，包括地址）Date(const Date&amp; d){_year = d._year;_month = d._month;_day = d._day;}哪些类的拷贝构造函数用户一定要提供？对象中有资源（动态的顺序表，若拷贝s1到s2时，因为要进行free，先free的是s2，在free之后s2指向空间已经被销毁而s1并不知道，所以在s1 free的时候出错）]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
