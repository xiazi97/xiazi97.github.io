<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络基础（一）]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据传输（ (不)同主机上的进程间同信） 协议：(通信双方的一个数据格式协议) 网络中主机之间进行通信也必须使用相同的协议（相同的一个光电信号格式） 计算机如何传播数据—-光电波信号 在网络中因为主机设备的生产厂商很多，每个厂商如果都使用自己的协议进行通信，那么将导致网络上主机间无法正常通信，于是设计了一个标准的协议 网络间的数据传输就必须使用同一个标准协议 ——-网络通信协议 在网络通信中，因为应对场景各有不同，因此协议也相对特别复杂，为了使用起来更加方便，因此就有了协议的封装/分层。 协议的封装/分层：按照各个协议的不同功能以及不同的应对场景对不同的协议进行了分层，在特定的环境下如果协议的分层清晰明了，那么使用/替换起来就更加方便 OSI网络互联七层参考模型： 优点：1.将服务，接口和协议明确区分开来 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP/IP五层模型： TCP/IP五层模型：TCP/IP指的是一个协议簇，因为TCP协议和IP协议是最典型的两个协议，因此这个协议簇就拿这两个协议名字进行命名了 应用层 :负责应用程序间的数据沟通 http/https ftp 传输层（内部完成）：负责端与端之间的数据传输（进程与进程间）TCP/UDP 网络层:负责地址管理和路由选择 IP (路由器) 数据链路层:负责相邻设备节点间的数据传输 以太网协议 交换机 物理层：负责光电信号的传输 以太网协议 集线器 数据的传输流程： 套接字编程——–原始的网络socket编程 IP地址：唯一定位网络上的主机（无符号四个字节的整数——uint32_t） 端口：标识一台主机上的进程（无符号两个字节的数据 uint16_t ,0~65535） 进程的标识为什么不用PID？ 因为PID会随着进程的创建改变的 sip+sport+dip+dport+proto 五元组 网络字节序：大小端 大端字节序：低地址存高位 0x01 02 03 04 uchar buf[4] 01 02 03 04 小端字节序：低地址存低位 uchar buf[4] 04 03 02 01 所以不同字节序主机之间进行数据传输，将造成数据的逆序，也就是得不到人家真正发送的数据。因此，约定了在网络间进行通信时必须使用大端字节序—-网络字节序，也就意味着如果我们的主机时小端字节序，那么通信时就需要对数据逆序，但是并不是所有数据都需要逆序，主要针对在内存中存储时，占据字节大于1个字节的数据（short,int,float,double,long等,针对这些类型的是数据，因为在内存中的存储跟展示顺序刚好相反，而发送时按字节发送对方按字节接收，那么如果对方时大端，因为低地址存高位，因为存储顺序和使用顺序完全相同，导致数据跟实际想发送的数据顺序刚好相反，因此需要进行字节逆序转换） 主机字节序：当前主机的字节序—–大小端不一定，取决于CPU的架构 x86（小端） MIP5（大端） RISC-V 网络套接字编程：（主要说的时传输层的TCP/UDP） 因为传输层有两个传输协议，所以必须选择其一进行数据传输，那么如何选择？ 答：TCP：面向连接，可靠传输，字节流服务 优点：可靠传输，并且传输灵活 缺点：传输速度低，数据粘包 UDP：无连接，不可靠，面向数据报 优点：传输数据快，无粘包 缺点：不可靠 针对数据安全性要求高的场景（文件传输）：使用TCP保证数据的可靠 安全性要求不是很高但是实时性要求高的场景（视频传输）：使用UDP保证传输速度 socket套接字编程： 网络编程涉及到对网卡的操作，因此操作系统就提供了一套接口—socket接口 网络编程中分了两个端：客户端程序和服务端程序（在网络编程中，客户端是主动的一方，并且客户端必须知道服务端的地址信息ip+port，而服务端需要在这个指定的地址等着） UDP编程步骤： 服务端： 创建套接字（建立网卡与进程之间的关系） 为套接字绑定地址信息（声明去网卡接收数据时找所需要的正确数据） 接收/发送数据 关闭套接字]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[对象之间可以进行复制操作，包括采用拷贝构造函数的方式用一个对象去构造另一个对象（用一个对象的值初始化一个新的构造的对象），如同指针的复制一样，对象复制也分为浅复制和深复制 对象浅拷贝： 两个对象之间进行复制时，若复制完成后，他们还共同使用着某些资源（内存空间），其中一个对象的销毁会影响另一个对象（动态顺序表） 如果没有显式提供拷贝构造函数与赋值运算符重载，编译器会生成一个默认的拷贝构造函数和运算符重载（默认为位的拷贝，将一个对象中的内容原封不动的拷贝到到另一个对象中。如果类中涉及到资源管理，则会使得多个对象在底层共用同一块资源，在销毁对象时，就会导致一份资源释放多次引起程序崩溃） 如果一个类中涉及到资源，该类必须显式提供拷贝构造含糊，赋值运算符重载函数，析构函数 //类似系统生成的默认拷贝构造函数的方式 ​ //值的拷贝方式—–内存的拷贝 ​ //后果：多个对象共用同一份资源，在销毁时同一份资源被释放多次而引起程序的崩溃 12345String(const String&amp; s) :str(s.str) //当前对象的指针和s里的字符串共用同一段空间 &#123;&#125; ​ 对象深拷贝： 当两个对象之间进行复制时，若复制完成后，它们不会共享任何资源（内存空间），其中一个对象的销毁不会影响另一个对象 ​ 123456789String(const String&amp; s) :str(new char[strlen(s.str) + 1]) //先分配一段空间 &#123; strcpy(str,s.str); &#125; 此时查看监视，发现s1与s2地址空间并不一样，不会产生内存泄露问题，也可以正常析构销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404#include&lt;assert.h&gt;#include&lt;iostream&gt;using namespace std;#if 0 浅拷贝问题的String类class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; //assert(str); //断言检测是否为空 if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); /* if(nullptr == str) &#123; //_str = new char //分配一个字节的空间,但在下边析构时需要与delete匹配起来使用，为了方便，将其设为以下形式 _str = new[1] char; *_str = &quot;\0&quot; &#125; else &#123; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; */ &#125; //类似系统生成的默认拷贝构造函数的方式 //值的拷贝方式-----内存的拷贝 //后果：多个对象共用同一份资源，在销毁时同一份资源被释放多次而引起程序的崩溃 String(const String&amp; s) :_str(s._str) //当前对象的指针和s里的字符串共用同一段空间 &#123;&#125; //类似系统生成的默认的赋值运算符重载的方式 //问题：1.内存泄露 // 2.与拷贝构造函数类似 String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; _str = s._str; return *this; &#125; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void TestString()&#123; String s1(&quot;hello&quot;); String s2(s1); //用s1拷贝构造s2，因为没有自己给出拷贝构造函数，系统会默认使用类生成的拷贝构造函数进行值的拷贝（浅拷贝）,销毁期间会对一段资源销毁两次产生程序而崩溃 String s2 = s1; //此时会看到s2本身有一个地址空间，但是在赋值时完全将s1中的东西拷贝，使得s2本来的空间找不到了，产生内存泄漏&#125;#endif#if 0使用深拷贝进行处理 传统方式class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; //assert(str); //断言检测是否为空 if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); /* if(nullptr == str) &#123; //_str = new char //分配一个字节的空间,但在下边析构时需要与delete匹配起来使用，为了方便，将其设为以下形式 _str = new[1] char; *_str = &quot;\0&quot; &#125; else &#123; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; */ &#125; String(const String&amp; s) :_str(new char[strlen(s._str) + 1]) //先分配一段空间 &#123; strcpy(_str,s._str); &#125; String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; /* 释放旧空间，开辟新空间，再进行字符串拷贝 delete[] _str; //因为先释放了原来空间，如果开辟新空间失败了，那么会造成影响 _str = new char[strlen(s._str) + 1]; strcpy(_str,s._str); */ char* pStr = new char[strlen(s._str) + 1]; strcpy(_str,s._str); delete[] _str; //释放掉旧空间 _str = pStr; &#125; return *this; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1);&#125;int main()&#123; Test(); return 0;&#125;#endif#if 0现代版写法，代码较简洁class String&#123;public: String(const char* str = &quot;&quot;) //创建空的字符串 &#123; if(nullptr == str) str = &quot;&quot;; //如果为空那么就当作空字符串 _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; String(const String&amp; s)//注意！本编译器下此时_str没有进行初始化，放的是一个随机值，所以在释放strTemp时出错，所以需要给一个初始值 :_str(nullptr) &#123; String strTemp(s._str); swap(_str,strTemp._str); &#125; /* String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; String strTemp(s); swap(_str,strTemp._str); &#125; return *this; //当前对象用的是临时对象的空间，出了作用域销毁临时对象，实际是将当前对象的地址空间释放了 &#125; */ String&amp; operator=(String s) &#123; swap(_str,s._str); return *this; &#125; ~String() &#123; if(_str) //判断是否有空间 &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str;&#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; s3 = s2; //此时实际是临时对象给s3赋值的&#125;int main()&#123; Test(); return 0;&#125;#endif#if 0class String&#123;public: String(const char* str = &quot;&quot;) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); _count = 1; &#125; String(String&amp; s) :_str(s._str) ,_count(++s._count) &#123;&#125; ~String() &#123; if(0 == --_count &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str; int _count; //每个对象中均有一份，一个对象修改了其他对象不知道&#125;;#endif/*static也不可以class String&#123;public: String(const char* str = &quot;&quot;) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); _count = 1; &#125; String(String&amp; s) :_str(s._str) &#123; ++_count; &#125; ~String() &#123; if(0 == --_count &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; &#125; &#125;private: char* _str; static int _count; //所有对象共享的，但资源有可能会有多分，每调用一次构造就将_count置为1了，不能针对多份资源，如 String s3;&#125;;int String::_count = 0;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; //此时会出现问题，到这里时_count重新被置为1，导致只能将s3释放而无法释放s1和s2&#125;int main()&#123; Test(); return 0;&#125;*/#if 0//写时拷贝（COW copy on write）:浅拷贝+引用计数+在向对象写内容时，是否需要给当前对象独立空间class String&#123;public: String(const char* str = &quot;&quot;) :_pCount(new int(1)) &#123; if(nullptr == str) str = &quot;&quot;; _str = new char[strlen(str) + 1]; strcpy(_str,str); &#125; String(String&amp; s) :_str(s._str) ,_pCount(s._pCount) &#123; ++*(_pCount); &#125; String&amp; operator=(const String&amp; s) &#123; if(this != &amp;s) &#123; if(0 == --(*_pCount) &amp;&amp; _str) //检测拷贝以后自己的资源需不需要释放 &#123; delete[] _str; _str = nullptr; delete _pCount; _pCount = nullptr; &#125; //与被拷贝的资源共享资源 _str = s._str; _pCount = s._pCount; //新资源计数+1 ++(*_pCount); &#125; return *this; &#125; char&amp; operator[](size_t index) //返回引用是因为有可能返回后作为左值 &#123; if(*_pCount &gt; 1) &#123; String str(_str); this-&gt;Swap(str); &#125; return _str[index]; &#125; const char&amp; operator[](size_t index)const &#123; return _str[index]; &#125; ~String() &#123; if(0 == --(*_pCount) &amp;&amp; _str) &#123; delete[] _str; _str = nullptr; delete _pCount; _pCount = nullptr; &#125; &#125; void Swap(String&amp; s) &#123; swap(_str,s._str); swap(_pCount,s._pCount); &#125;private: char* _str; int* _pCount; &#125;;void Test()&#123; String s1(&quot;hello&quot;); String s2(s1); String s3; //s3 = s1; s1 = s3; s1[0] = &apos;H&apos;; //此时一改变会全改变，s1,s2,s3共用一份资源&#125;int main()&#123; return 0;&#125;#endif]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[如何实现一个通用的函数呢？（如针对不同的参数类型均可） 使用函数重载可以实现，但是使得代码复用率和可维护性比较低 泛型编程： 编写与类型无关，与使用场景无关的通用代码，使得代码可以复用 模板： 函数模板：是一个函数家族，与类型无关，使用时才被参数化，根据实参类型产生函数的适用版本 template //模板参数列表 可以使用template ，不可以使用struct T1 _Add(T1 left,T2 right) //函数模板 { ​ return left + right; } 实例化： 隐式实例化： 编译器根据实参推演模板参数的实际类型 显示实例化：函数名和后加&lt;&gt;指定参数实际类型 匹配原则： 1.优先调用自己写的模板函数 2.模板函数不允许自动类型转换，普通函数可以自动类型转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#pragma once#include&lt;assert.h&gt;#include&lt;iostream&gt;using namespace std;#if 0//不是一个真正的函数template&lt;class T&gt; //模板参数列表 可以使用template&lt;typename T&gt; ，不可以使用struct T _Add(T left,T right) //函数模板&#123; return left + right;&#125;template&lt;class T&gt;void PrintfArray(T array,int size) //数组会自己转换类型&#123; cout&lt;&lt;typeid(array).name() &lt;&lt;endl; int i = 0; for(i=0;i&lt;size;i++) &#123; cout&lt;&lt; array[i] &lt;&lt; &quot; &quot;; cout&lt;&lt;endl; &#125;&#125;int main()&#123; int array[] = &#123;1,2,3,4,&#125;; char str[] = &quot;hello&quot;; PrintfArray(array,sizeof(array)/sizeof(int)); PrintfArray(str,strlen(str)); //隐式实例化---不会进行隐式的类型转化，需要用户自己来强转/ cout&lt;&lt; _Add(1,2) &lt;&lt;endl; //根据实参类型来进行类型推演生成处理具体类型的函数 cout&lt;&lt; _Add(1,(int)2.0) &lt;&lt;endl; //但是面对参数为不同类型时无法判断如何输出，需要对参数进行处理，如强转类型 //显式实例化 _Add&lt;int&gt;(1,2.2); _Add&lt;&gt;(1,2); //隐式实例化 return 0;&#125;#endif#if 0template&lt;class T&gt;class Seqlist&#123;public: Seqlist(int capacity = 10) :_Data(new T[capacity]) ,_capacity(capacity) ,_size(0) &#123;&#125; //拷贝构造：Seqlist(const Seqlist&lt;T&gt;&amp; s); //赋值运算符重载：Seqlist&lt;T&gt;&amp; operator = (const Seqlist&lt;T&gt;&amp; s) void PushBack(const T&amp; data) &#123; _CheckCapacity(); _Data[_size++] = data; &#125; void PopBack() &#123; if(_size != 0) --_size; &#125; //访问任意位置 T&amp; operator[](size_t index) //可能会修改s[i]中的元素 &#123; assert(index &lt; _size); return _Data[index]; &#125; //因为const类型的对象不能调用普通函数，这里是const对象访问 const T&amp; operator[](size_t index) const &#123; assert(index &lt; _size); return _Data[index]; &#125; //访问第一个元素 T&amp; Front() &#123; return _Data[0]; &#125; const T&amp; Front()const &#123; return _Data[0]; &#125; //访问最后一个元素 T&amp; Back() &#123; return _Data[_size-1]; &#125; const T&amp; Back()const &#123; return _Data[_size-1]; &#125; size_t Size() const &#123; return _size; &#125; size_t Capacity() const &#123; return _capacity; &#125; void Clear() &#123; _size = 0; &#125; ~Seqlist();private: void _CheckCapacity() &#123; if(_size == _capacity) &#123; size_t newCapacity = (_capacity&lt;&lt;1); //申请空间 T* Temp = new T[newCapacity]; //拷贝元素 memcpy(Temp,_Data,_size*sizeof(T)); //释放旧空间 delete[] _Data; //替换新空间 _Data = Temp; _capacity = newCapacity; &#125; &#125;private: T* _Data; size_t _capacity; size_t _size;&#125;;template&lt;class T&gt;Seqlist&lt;T&gt;::~Seqlist()&#123; if(_Data) &#123; delete[] _Data; _Data = nullptr; _capacity = 0; _size = 0; &#125;&#125;void TestSeqlist()&#123; Seqlist&lt;int&gt; s1; Seqlist&lt;double&gt; s2; Seqlist&lt;char&gt; s3; s1.PushBack(1); s1.PushBack(2); s1.PushBack(3); s1.PushBack(4); s1[0] = 6; cout&lt;&lt; s1.Size()&lt;&lt;endl; cout&lt;&lt; s1.Front()&lt;&lt;endl; cout&lt;&lt; s1.Back()&lt;&lt;endl; s1.Clear(); cout&lt;&lt;s1.Size()&lt;&lt;endl;&#125;#include&lt;string&gt;void Test()&#123; Seqlist&lt;string&gt; s; s.PushBack(&quot;0000&quot;); s.PushBack(&quot;1111&quot;); s.PushBack(&quot;2222&quot;); s.PushBack(&quot;3333&quot;); s.PushBack(&quot;4444&quot;); s.PushBack(&quot;5555&quot;); s.PushBack(&quot;6666&quot;); s.PushBack(&quot;7777&quot;); s.PushBack(&quot;8888&quot;); s.PushBack(&quot;9999&quot;);&#125;int main()&#123; //TestSeqlist(); Test(); return 0;&#125;#endif]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态内存管理]]></title>
    <url>%2F2018%2F11%2F15%2F%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[父子进程之SIGCHLD]]></title>
    <url>%2F2018%2F11%2F11%2F%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8BSIGCHLD%2F</url>
    <content type="text"><![CDATA[​ 在用wait和waitpid函数处理僵尸进程时，父进程可以阻塞等待子进程结束，也可以非阻塞的查询是否有子进程结束等待处理。但是，第一种方式父进程阻塞了就不能处理自己的工作了，而第二种父进程在处理自己的工作时还需要时不时的轮询一下，使得程序变得复杂。而在子进程终止时，会给父进程发送SIGCHLD信号，该信号的默认处理是忽略，父进程可以自定义该函数，使得父进程可以专心处理自己的工作不必关心子进程，而在子进程终止时会通知父进程，父进程在信号处理函数中调用wait清理子进程即可。 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;signal.h&gt;#include&lt;stdlib.h&gt;void sigcb()&#123; //使用非阻塞的循环来处理SIGCHLD信号 //因为SIGCHLD信号是不可靠信号，有可能会丢失 //一旦接受到信号就处理到不能处理为止 //!=0代表一直有子程序在退出，所以一直循环，&gt;0返回子进程PID (!=0可能&lt;0，没有子进程） while(waitpid(-1,NULL,WNOHANG) != 0);//多个子进程可能会同时退出，如果同时退出了那么有些信号就会丢失，使得少处理一个信号 printf(&quot;Have a child exit!\n&quot;);&#125;int main()&#123; signal(SIGCHLD,sigcb); int pid = fork(); if(pid == 0) &#123; exit(0); &#125; //waitpid(-1,NULL,0); //避免产生僵尸子进程，但是使得父进程中后续的操作不能正常继续 while(1) &#123; printf(&quot;--------\n&quot;); sleep(1;) &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可重入函数]]></title>
    <url>%2F2018%2F11%2F10%2F%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不可重入函数：如果函数在不同的地方/时序进行调用，会对函数的功能逻辑造成影响 可重入函数：不管怎么调用都不会对函数内部功能/程序逻辑造成影响（局部变量） 下面具体演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 这是一个演示signal接口修改信号处理方式的demo* 信号的处理方式有三种：* 忽略* 默认* 自定义*/ #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; #include&lt;signal.h&gt; void sigcb(int signo) &#123; static int a= 1;//静态变量，再次进入可能会产生不是预期的结果 static int b = 1; int c = 0; a++; sleep(10); b++; c= a + b; printf(&quot;receive signo:%d---%d\n&quot;,signo,c);/* if(signo == SIGINT ) //因为可能有很多信号来调用这个函数，所以需要做出判断 &#123; &#125; else &#123; &#125; */ return; &#125; int main() &#123; // sighandler_t signal(int signum, sighandler_t handler); //signum:信号的编号 //handler：处理方式 // SIG_IGN 忽略 // SIG_DFL 默认 int i = 0; //signal(SIGINT,SIG_IGN); //提前备注，当这个信号到来时忽略它 signal(SIGINT,sigcb); //自定义方式处理 while(1) &#123; /*printf(&quot;--------------\n&quot;); kill(getpid(),SIGINT); if(++i == 3) &#123; signal(SIGINT,SIG_DFL); &#125;*/ sigcb(SIGQUIT); &#125; return 0; &#125; 运行程序时输入Ctrl+C，发现出现下边的情况： 这是为什么呢？图解如下： 不可重入函数的要点（什么函数是不可重入函数）： 1.函数内部包含有对全局性变量的修改操作 2.函数传参的参数跟其他地方共同使用同一个变量 因为这些对全局变量的操作不是原子性的，因此这些修改操作有可能同时在不同地方进行修改 一个函数是否可重入： 1.是否对全局性的数据进行修改操作（malloc是用全局链表来管理堆的） 2.这个操作是否是原子性的]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号之自定义处理]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[信号的捕捉流程：主要是针对信号的自定义处理方式 信号并不是立即处理的，而是选择一个合适的时机去处理，合适的时机就是当前程序从内核态切换到用户态的时候 注意：程序如何从用户态切换到内核态? 答：1.程序异常的时候 2.发起系统调用的时候 3.中断的时候 信号的捕捉是当我们发起系统调用/程序异常/中断当前程序从内核态运行切换到用户态，去处理这些事情，处理完毕之后，要从内核态返回用户态，但是在返回之前会看一下是否有信号需要被处理，如果有就处理信号（切换到用户态执行信号的自定义处理方式），处理完毕之后再次返回内核态，判断没有信号要处理了就调用sys_sigreturn返回用户态（我们程序之前运行的位置）（就像我们课堂上布置的作业不会立即写） 注意：在使用这个接口时可能会因为该函数是库函数，而在Linux下的系统版本下会有细微差异 多是使用此函数所调用的系统调用接口sigaction 123456789int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);signum:指定给哪个信号去自定义处理方式act：新的处理方式oldact：保存新自定义之前的原本的操作 12345678910111213141516171819struct sigaction &#123;//都是信号的回调函数（取决于flags），任意指定其一 void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *);//传递信号并同时携带参数//当处理时不希望被别的信号所影响，所以使用sa_mask来指定需要暂时阻塞的信号 sigset_t sa_mask;//当flags被指定为SA_SIGINFO这个参数时回调的是sa_sigaction，否则都是调用handler int sa_flags; void (*sa_restorer)(void); &#125;; 下边是一个sigaction的使用demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 1 /* 2 * 因为signal这个接口有linux版本的差异性，因此可以使用sigaction这个接口来替代signal函数， 3 * 它的功能也是自定义信号的处理方式，并且signal函数内部也是通过sigaction来实现的 4 * 5 * 6 */ 7 8 /* struct sigaction &#123; 9 void (*sa_handler)(int);//处理函数 10 void (*sa_sigaction)(int, siginfo_t *, void *);//处理函数（当flags被指定为SA_SIGINFO这个参数时回调） 11 sigset_t sa_mask;//在处理信号时通过这个mask暂时阻塞一些信号，处理完之后还原 12 int sa_flags;//决定使用哪个处理接口 13 void (*sa_restorer)(void); 14 &#125;;*/ 15 16 17 #include&lt;stdio.h&gt; 18 #include&lt;unistd.h&gt; 19 #include&lt;signal.h&gt; 20 21 void sigcb(int signo) 22 &#123; 23 printf(&quot;rec signal:%d\n&quot;,signo); 24 &#125; 25 26 void sigcb1(int signo,siginfo_t* info,void* context)//context为预留的，不是传的参数，暂时不管它 27 &#123; 28 printf(&quot;rec signo:%d---param:%d\n&quot;,signo,info-&gt;si_int); 29 &#125; 30 31 32 int main() 33 &#123;34 struct sigaction new_act; 35 struct sigaction old_act; 36 //重新定义处理方式的信号为SIGINT SINQUIT 37 //int sigaction(int signum, const struct sigaction *act, 38 // struct sigaction *oldact); 39 //signum:信号编号 40 //act:新的处理方式 41 //oldact:保存原有的处理方式 42 43 //这个操作时一般性的更改一个信号的处理方式，sa_flags =0代表使用的回调接口为sa_handler 44 sigemptyset(&amp;new_act.sa_mask); 45 new_act.sa_flags = 0; 46 new_act.sa_handler = sigcb; 47 sigaction(SIGINT,&amp;new_act,&amp;old_act); 48 49 //这个操作是用于传递信号同时携带参数的情况，sa_flags需要被指定为sa_SIGINFO,并且调用的接口是sa_sigaction 50 sigemptyset(&amp;new_act.sa_mask); 51 new_act.sa_flags = SA_SIGINFO; 52 new_act.sa_sigaction = sigcb1; 53 sigaction(SIGQUIT,&amp;new_act,&amp;old_act); 54 while(1) 55 &#123; 56 sleep(1); 57 kill(getpid(),SIGINT); 58 //int sigqueue(pid_t pid, int sig, const union sigval value); //这个函数不仅可以发送信号，还可以 //顺便携带一 个信号 59 // pid:进程ID 60 // sig:信号编号 61 // sigval:参数 62 /* union sigval &#123; 63 int sival_int; 64 void *sival_ptr; 65 &#125;;*/ 66 union sigval val; 67 val.sival_int = 999; 68 sigqueue(getpid(),SIGQUIT,val);//传参函数 69 &#125; 70 return 0; 71 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件权限]]></title>
    <url>%2F2018%2F11%2F08%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[​ 在Linux系统下，一切皆文件，而对于一个文件必定需要权限去对其进行访问和操作，那么对于用户来说，可以通过哪些权限来访问文件呢？ ​ 首先，我们需要对Linux系统下文件访问权限有一定的了解：​ 文件权限值的表示方法： ​ 1.字符表示法： ​ 2.8进制数值表示法 那么如何设置且更改文件的访问权限呢？ ​ 使用chmod命令：格式为chmod[参数]权限 文件名 1.用户标识符+-=权限字符 ​ +：向权限范围增加权限代号所表示的权限 ​ -： 向权限范围取消权限代号所表示的权限 ​ =: 向权限范围赋予权限代号所表示的权限 ​ 用户符号： ​ u：拥有着 ​ g：拥有者同组用 ​ o：其他用户 ​ a：所有用户 chmod u+w /home/abc/txt chmod o-x /home/abc/txt chmod a=x /home/abc/txt 2.三位8进制数字 chmod 664 /home/abc/txt chmod 640 /home/abc/txt 下面进行具体的操作： 1.创建一个目录，并将其权限改为000 ​ 2.此时进入目录发现权限不够 3.给该目录所有者加上读权限，并尝试进入目录，发现权限不够 4.将该目录所有者的读权限取掉，加上写权限，进入目录，发现权限不够 5.将该目录所有者的写权限取掉，加上执行权限，进入目录，可以进入 由此可得： 1.读（r/4）：Read对文件而言，具有读取文件内容的权限 ​ 对于目录来说，具有浏览该目录信息的权限 2.写（w/2）：Write对文件而言，具有修改文件内容的权限 ​ 对于目录来货，具有删除移动目录内文件的权限 3.执行（x/1）：Execute对文件而言，具有执行文件的权限 ​ 对于文件而言，具有执行文件的权限 ​ 对于目录来说，具有进入**目录**的权限]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程信号之信号周期]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E4%B9%8B%E4%BF%A1%E5%8F%B7%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[信号是为了通知进程发生了某个事件，因为事件比较紧急，因此会打断当前进程正在执行的工作，然后去处理事件，事件处理完毕之后进程回到原先运行位置继续运行信号更多的是通知事件发生，如红绿灯 在LInux下，用户输入命令在Shell下启动一个前台进程，而当按下ctrl+C时，产生一个硬中断，如果说CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断（终端驱动程序将 ctrl+c 解释成一个SIGINT信号，记在其进程的PCB中(也可以说是发送了一个SIGINT信号给该进程)),而当要从内核返回到进程的用户空间代码继续执行之前，首先处理PCB中记录的信号，此时会发现有一个SIGINT信号待处理，而这个信号的默认处理动作是终止进程，所以直接终止进程而不再返回它的用户空间代码执行 信号产生之后第一时间也不是直接处理而是先存储下来，处理信号 信号的生命周期：信号的产生 =》信号的注册 =》信号的注销 =》(信号的阻塞（只是不处理）) =》信号的处理 信号处理常见方式：1.忽略此信号2.执行该信号的默认处理动作3.提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号） 信号分了两类：1.非实时信号（不可靠信号）1~31 实时信号 (可靠信号) 34~64 信号的产生：1.通过硬件中断产生 （ctrl+c）2.程序异常产生 SIGFPE SIGSEGV3.软件条件(代码)产生软件条件产生：1.直接使用kill命令：kill并不是真的杀死进程，而是向一个进程发送一个信号（SIGTERM）kill -15 PID kill -15 PID2.kill接口int kill(pid_t pid, int sig); 向指定的进程发送指定的信号int raise(int sig); 发送一个信号给自身void abort(void); 使当前进程接受到信号而异常终止(像exit一样总会成功，所以没有返回值) unsigned int alarm(unsigned int seconds);在second秒之后，给进程发送一个STGALRM信号，在函数中可以多次调用如：设置一个定时器，取消上一个定时器，并且返回上一个定时器剩余时间 信号的注册：信号的注册（给一个进程发送信号），就是修改这个进程pcb中关于信号的pending位图，将相应的信号位置1 信号的阻塞：暂时不处理信号，并不是不接收信号，实际是暂时阻止信号的递达原理：要阻塞一个信号，那么就是修改pcb中关于信号的block位图，将相应的信号位置1，这个位图就像是 一个备注说明如果接收到这个信号暂时不处理注意：1.实际执行信号的处理动作称之为信号递达（动作）2.信号从产生到递达之间的状态，称之为信号未决（状态）3.进程可以选择阻塞某个信号4.被阻塞的信号产生时将保持在未决状态，知道进程解除对该信号的阻塞才执行递达动作5.阻塞和忽略时不同的，阻塞就不会递达，而忽略则是在递达之后可选的一种处理的动作 sigprocmask：int sigprocmask(int how, const sigset_t set, sigset_t oldset);调用sigprcmask（）接口，要么阻塞函数，要么对信号进行解除阻塞set：要阻塞或解除阻塞的集合oldset：保存原先阻塞集合中的信号如果oset非空，则读取进程当前的信号屏蔽字通过oset传出；若set非空，则根据how参数指示更改进程的信号屏蔽字；（解除阻塞或者设置阻塞）若oset和set均非空，则将原来的信号屏蔽字备份到oset中，然后根据how参数更改信号屏蔽字how参数：SIGBLOCKSIG_UNBLOCKSIG_SETMASKint sigemptyset(sigset_t set); int sigfillset(sigset_t set); int sigaddset(sigset_t set, int signum); int sigdelset(sigset_t set, int signum)； int sigismember(const sigset_t *set, int signum);123456789101112131415161718192021222324252627282930313233343536373839404142/* 这是一个演示信号阻塞的demo 2 */ 3 4 #include&lt;stdio.h&gt; 5 #include&lt;unistd.h&gt; 6 #include&lt;signal.h&gt; 7 8 int main() 9 &#123;10 //我要阻塞这个集合中的信号11 sigset_t new_block;12 //用于保存原来阻塞集合中的信号,防止后续要将阻塞集合还原回去13 sigset_t old_block;14 15 //int sigemptyset(sigset_t *set);16 //清空一个信号集合17 sigemptyset(&amp;new_block);18 //int sigfillset(sigset_t *set);19 //将所有的信号添加到set集合中20 // int sigaddset(sigset_t *set, int signum);21 //添加指定的单个信号到set集合中22 //int sigdelset(sigset_t *set, int signum);23 //从集合中移除一个信号24 //int sigismember(const sigset_t *set, int signum);25 //判断一个信号是否在一个集合中 26 sigfillset(&amp;new_block);27 //int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);28 //阻塞信号或解除阻塞29 //SIGBLOCK 阻塞集合中的信号30 //SIG_UNBLOCK 对集合中的信号解除阻塞31 //SIG_SETMASK 将集合中的信号设置到阻塞集合中32 //set：要阻塞或解除阻塞的集合33 //oldset：保存原先阻塞集合中的信号34 sigprocmask(SIG_BLOCK,&amp;new_block,&amp;old_block);35 //不按回车不往下走36 getchar();37 //解除阻塞38 sigprocmask(SIG_UNBLOCK,&amp;new_block,NULL);39 //将原先阻塞集合中的信号还原回去40 //sigprocmask(SIG_BLOCK,&amp;old_block,NULL);41 return 0;42 &#125; 有两个信号是不会被阻塞的：1.SIGKILL 2. SIGSTOPsigpending：获取一个未决信号int sigpending(sigset_t *set);（如果调用了sigpending接口，并且传入了一个集合地址，那么就会将pending集合中所有数据返回回来，相当于有哪些信号没有被处理则会返回回来） 信号注销：就是从pending集合中将即将要处理的信号置0（从pcb的pending集合中移除）非可靠信号注册就是将相应pending位图置1，然后添加一个sigqueue链表结构到链表中（一意味着这个信号来过），之后如果有相同信号到来，一看位图已经置1了，就不做操作了（意味着后来的信号在前一个信号未处理之前不会重复注册，代表丢了）可靠信号注册不管之前有没有注册都要置1 ，并且添加节点到链表中，所以不会丢掉信号 非可靠注销就是删除链表结点，相应位图置0可靠信号注销就是删除节点，判断是否有相同信号节点，如果没有位图置0，如果有就不置0，位图该位置还为1，下次会还处理这个信号struct sigqueue； 信号处理：1.忽略此信号——-直接将信号丢掉2.执行该信号的默认处理动作——-按照操作系统中对信号事件的既定处理方式3.自定义———-用户自己提供一个对信号处理的函数，要求内核在处理该信号时切换到用户状态执行这个函数（捕捉信号）哪些接口可以供我们改变处理方式：1.signal #include &lt;signal.h&gt; typedef void (sighandler_t)(int); //函数指针的类型定义 sighandler_t signal(int signum, sighandler_t handler); signum:信号的ID，指定要改变的信号 sighandler_t handler：*信号的处理方式SIG_IGN（忽略信号） SIG_DFL（默认处理方式） or 自定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 2 * 这是一个演示signal接口修改信号处理方式的demo 3 * 信号的处理方式有三种： 4 * 忽略 5 * 默认 6 * 自定义 7 */ 8 9 #include&lt;stdio.h&gt; 10 #include&lt;unistd.h&gt; 11 #include&lt;signal.h&gt; 12 13 14 void sigcb(int signo) 15 &#123; 16 printf(&quot;receive signo:%d\n&quot;,signo); 17 /* if(signo == SIGINT ) //因为可能有很多信号来调用这个函数，所以需要做出判断 18 &#123; 19 &#125; 20 else 21 &#123; 22 &#125; 23 */ 24 return; 25 &#125; 26 27 28 int main() 29 &#123; 30 // sighandler_t signal(int signum, sighandler_t handler); 31 //signum:信号的编号 32 //handler：处理方式 33 // SIG_IGN 忽略 34 // SIG_DFL 默认 35 int i = 0; 36 //signal(SIGINT,SIG_IGN); //提前备注，当这个信号到来时忽略它 37 signal(SIGINT,sigcb); //自定义方式处理 38 while(1) 39 &#123; 40 printf(&quot;--------------\n&quot;); 41 kill(getpid(),SIGINT); 42 if(++i == 3) 43 &#123; 44 signal(SIGINT,SIG_DFL); 45 &#125; 46 &#125; 47 return 0; 48 &#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Dump浅解析]]></title>
    <url>%2F2018%2F11%2F08%2FCore-Dump%E6%B5%85%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Core Dump（核心转储）：当一个进程要异常终止时，可以选择把进程的用户空间内存数据全部保存到磁盘上，文件名通常是core，叫做Core Dump(保存当前程序运行的数据以及调用栈信息)，可以用于错误原因定位调试 为什么不用gdb呢？答：如果程序运行错误，可以直接通过core文件来gdb调试（有些错误可能是偶然发生的，可能在gdb调试时并不会显露出来，只有在core dump记录之后才能快速定位进行调试） CoreDump默认关闭：确保隐私安全/资源占用，1.记录的信息里面可能有隐秘性信息（如用户名和密码）2.Core Dump 文件很大且不会自动清理CoreDump打开：ulimit -c （int）当这个值为0 时则关闭（一个进程产生多大的core文件取决于进程的Resource Limit(这个信息保存在PCB中),使用ulimit命令改变这个限制）ulimit命令实际是改变Shell进程的Resourse Limit 1.首先将Core Dump打开 2.运行死循环程序 3.新建窗口，查看PID，并kill该程序 4.重新回到程序运行界面，发现已经Core Dumped，而ls产生了一个CoreDump文件 5.使用Core Dump文件查看错误（core-file ./test.992） 此时查看调用栈信息可以看到：__kernel_vsyscall ()，即为因死循环终止]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new与delete的使用]]></title>
    <url>%2F2018%2F11%2F07%2Fnew%E4%B8%8Edelete%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[new运算符是给指针分配一片内存空间，与delete运算符一起使用，以达到直接进行动态内存分配和释放的目的new返回指定类型的一个指针，如果分配失败（如没有足够的内存空间），则返回012double *p；p = new double； 此时系统会根据double类型的空间大小来开辟一个内存空间，并将地址放在指针p中delete是释放new请求到的空间的 注意：1.delete必须来释放之前new分配的指针2.用new可以指定分配的内存大小1234int *p;p = new int(30); //为指针p开辟30个字节单元的内存单元...delete p; 3.new可以为数组分配内存，当释放时必须告诉delete数组中有多少元素1234int *p;p = new int[10];...delete [10] p ; 例：123456void Test()&#123;char* p;strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 此时只是给变量p分配了一个地址空间，并没有给p所指向的分配空间，所以程序出错应改为：1234567void Test()&#123;char *p;p = new char(10);strcpy(p,&quot;china&quot;);cout &lt;&lt; p &lt;&lt; endl;&#125; 注意：对于用new运算符创建的对象，必须使用delete才能调用析构函数问题：看以下代码：12A *pa = new A[10];delete pa; 则类A的构造函数和析构函数分别执行了几次（）答：构造函数执行了10次，析构函数构造了1次]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（二）]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[运算符重载： operator + 合法的运算符 构成函数名（举例：重载&lt;运算符的函数名：operator&lt; ）。 重载运算符以后，不能改变运算符的 优先级/结合性/操作数个数。3.若成员变量为共有的，则可以重载为全局函数；若为私有的，重载为成员函数编译器对于==运算符的重载进行的操作： 5个C++不能重载的运算符是哪些？1..* 2. :: 3.sizeof 4.?: 5..注意：1.不能通过连接其他符号来创建新的操作符：如operator@2.重载操作符必须有一个类类型或者枚举类型的操作数3.用于内置类型的操作符，其含义不能改变，如不能将+重载为-4.作为类成员的重载函数，其形参看起来比操作数少1，因为操作符一个默认的形参this，限定为第一个形参 赋值运算符的重载：1.赋值运算符的重载是对一个已存在的对象进行拷贝赋值 。2.当程序没有显式地提供一个以本类或本类的引用为参数的赋值运算符重载函数时，编译器会自动生成这样一个赋 值运算符重载函数思考：为什么operator=赋值函数需要一个 Date&amp;的返回值， 使用void做返回值可以吗？//void Date&amp; operator=(const Date&amp; d) //引用效率较高,优先考虑引用 { _year = d._year; _month = d._month; _day = d._day; return this; }d1 = d2 = d3;需要注意：1.类型参数 2.返回值 3.检测是否自己给自己赋值 4.返回this 类的const成员函数：const修饰普通变量在C++中，const修饰的变量已经为一个常量，具有宏的属性，即在编译期间，编译器会将const所修饰的常量进行替换。const修饰类成员 const修饰类成员变量时，该成员变量必须在构造函数的初始化列表中初始化 const修饰类成员函数，实际修饰该成员函数隐含的this指针，该成员函数中不能对类的任何成员进行修改（ const Test* const）注意：在const成员函数中不能修改类的“成员变量”，因为const在此处修饰的是this指针指向空间中的内容，若需要对类的某个成员变量进行修改，该成员变量只需被mutable关键字修饰即可 思考：首先明确一点：非const函数实际是可读可写当前对象的函数，如SetData()，而const函数只能读取当前对象的内容,如GetData() const对象可以调用非const成员函数和const成员函数吗？答：不能调用普通非const类型成员函数，可以调用const类型成员函数(只读不可写) 非const对象可以调用非const成员函数和const成员函数吗？答： 可以，非const对象本身就具有可读属性，完全可以使用const函数 const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：不能调用非const函数，可以调用const类型成员函数 非const成员函数内可以调用其它的const成员函数和非const成员函数吗？答：可以 类的取地址操作符重载 &amp; const修饰的取地址操作符重载 ：这两个默认成员函数一般不用重新定义 ，编译器默认会生成。当想让别人获取到你指定的内容才会需要你自己重载这两个操作符Test operator&amp;(){cout &lt;&lt; this &lt;&lt; endl;return this;} const Date operator&amp;() const{ return this ; }Test operator&amp;(); 和 const Test opertor&amp;();形成重载原因是：默认隐藏参数this指针类型不同，第一个是Test const，第二个是const Test const]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for循环的基础练习]]></title>
    <url>%2F2018%2F11%2F01%2Ffor%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[无论是对于编程菜鸟或者是大牛来说，for循环是一个不可或缺的C语言语句，在这里其定义如何且按下不表，只是单纯的放几个for循环的适用场景来感受一下。for(表达式1；表达式2；表达式3)，请对应于下图来认真体会一下好的，多说无益，还是上上手来实际操作一下第一题：打印100~200 之间的素数在做这道题的时候，个人建议自己先想清楚什么是素数，如何判断一个数是不是素数，切忌没有想清楚就直接上手，建议在实操之前先写一下伪代码以下提供三种方式来处理这个问题：1.有多少个数就判断多少次，这种方法简单明了，一眼即懂，但是大大增加了代码的循环次数123456789101112131415void IsPrime1()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;i;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= i) printf(&quot;%d &quot;,i); &#125;&#125; 2.这一种较第一种减少了大概一般的循环次数，提高了代码效率123456789101112131415void IsPrime2()&#123; int i = 100; for(i=101;i&lt;200;i++) &#123; int j = 2; for(j=2;j&lt;200/2;j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= (i/2)) printf(&quot;%d &quot;,i); &#125;&#125; 3.此时的循环次数由n级数骤降到了sqrt(n)级上,但是针对这一种算法，一定要拎清楚输出的条件123456789101112131415void IsPrime3()&#123; int i = 100; for(i=101;i&lt;200;i+=2) &#123; int j = 2; for(j=2;j&lt;sqrt(1.0*i);j++) &#123; if(i%j == 0) break; &#125; if(j &gt;= sqrt(1.0*i)) printf(&quot;%d &quot;,i); &#125;&#125; sqrt()是C语言函数库中封装好的函数，其在库中对参数分别为double,float,long double，有着三种不同的重载方式，此段代码中sqrt()中参数为1.0*i即是为了满足参数，方能调用该函数，切记要加头文件&lt;math.h&gt;二.输出乘法口诀表因为要输出成如图界面，一定要注意循环终止条件1234567891011121314void mul()&#123; int i = 0; for(i=1;i&lt;=9;i++) &#123; int j = 0; for(j=1;j&lt;=i;j++) &#123; int k = i*j; printf( &quot;%d*%d = %2d &quot;,j,i,k); &#125; printf(&quot;\n&quot;); &#125;&#125; 三. 判断1000年—2000年之间的闰年1234567891011void IsLeapYear()&#123; int year; for (year = 1000; year &lt;= 2000; year++) &#123; if (year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0 ) &#123; printf(&quot;%d &quot;, year); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>C初阶基本练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类中默认成员函数浅析（一）]]></title>
    <url>%2F2018%2F10%2F30%2F%E7%B1%BB%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数：是一个特殊的成员函数（随着对象创建而自动被调用的），用于来初始化对象，在对象的生命周期中只调用一次特征：1.名字与类名相同2.无返回值（并不等同于void）3.可以重载（类可以有多个构造函数，其名字都必须相同但参数列表可以不同）4.类对象创建时自动执行！！！5.构造函数可以在类中定义，也可以在类外定义（在类中定义的成员函数，编译器可能会将其当成内联函数来处理）class Date(){public：/Date() //无参数，形成重载{_year = 1997;_month = 01;_day = 01;}/Date(int year,int month,int day) //无返回值类型，并不是void{_year = year;_month = month;_day = day;}private:int _year;int _month;int _day;} 注意：1.若一个类没有定义构造函数，则会自动生成一个不带参数的默认构造函数Date(){}; 此时创建Date d对象会报错，如何解决？答：将Date(int year,int month,int day)给上缺省值，即Date(int year = 1997,int month = 01,int day = 01)，使得对象若没有参数则直接使用缺省值（无参的和带有全缺省的构造函数只能存在一个，即Date（）{}；和Date(int year = 1997,int month = 01,int day = 01只能存在一个) 析构函数：与构造函数功能相反（~），在对象被销毁时编译器自动调用，析构函数体做一些对象删除前的相关资源清理工作（不是删除对象）特征： 析构函数名是在类名前加上字符 ~。 无参数无返回值。 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数注意：对于用new运算符动态创建的对象，只有用delete释放对象时才调用析构函数 拷贝构造函数：用已经存在的对象创建新的对象只有单个形参，该形参是对本类类型对象的引用（因为是拷贝，不需要更改原对象的任何参数，为了安全起见一般常用const修饰）特征： 拷贝构造函数其实是一个构造函数的重载。 拷贝构造函数的参数只有一个且必须使用引用传参（使用传值方式会引发无穷递归调用） 若未显示定义，系统会默认生成默认的拷贝构造函数。 默认的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化（默认方式下是原封不动完全拷贝，包括地址）Date(const Date&amp; d){_year = d._year;_month = d._month;_day = d._day;}哪些类的拷贝构造函数用户一定要提供？对象中有资源（动态的顺序表，若拷贝s1到s2时，因为要进行free，先free的是s2，在free之后s2指向空间已经被销毁而s1并不知道，所以在s1 free的时候出错）]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
